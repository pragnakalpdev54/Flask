# Flask Test Task 2 â€“ Relational DB & Service Layer

> **STOP**: Do not attempt this task until you have completed [Level 3: Authentication](06_LEVEL_3_AUTHENTICATION.md).
> **Next Level**: [Level 4: Scalable Structure](08_LEVEL_4_SCALABLE.md)

> [!TIP]
> **OOP Tip**: You will need to create a `BookService` and `AuthorService`. Remember, these are just **Namespaces** (collections of functions). You don't need to do complex OOP inheritance.

## Objective

Build a Flask-based REST API that interacts with a SQLite database using **Flask-SQLAlchemy**.
This task evaluates:

* Database Modeling (One-to-Many relationships)
* Migration Management
* **Service Layer Pattern** (Crucial)
* Error Handling

## Problem Statement

Create a **Library Management API** that manages `Authors` and `Books`.

* An `Author` can have multiple `Books`.
* A `Book` belongs to one `Author`.

## Data Models

### Author

* `id`: Integer, Primary Key
* `name`: String, required, unique
* `bio`: String, optional

### Book

* `id`: Integer, Primary Key
* `title`: String, required
* `price`: Float, required
* `author_id`: Integer, Foreign Key to `Author`

## API Requirements

### 1. Create Author

**POST** `/authors`

```json
{
  "name": "J.K. Rowling",
  "bio": "British author..."
}
```

* **Constraint**: Name must be unique. Return 400 if exists.

### 2. Create Book

**POST** `/books`

```json
{
  "title": "Harry Potter",
  "price": 19.99,
  "author_id": 1
}
```

* **Validation**:
  * Return **400** if `author_id` field is missing from request body
  * Return **404** if `author_id` is provided but Author with that ID doesn't exist in database

### 3. Get Author with Books

**GET** `/authors/<id>`

**Response**:

```json
{
  "id": 1,
  "name": "J.K. Rowling",
  "bio": "...",
  "books": [
    {"id": 1, "title": "Harry Potter", "price": 19.99}
  ]
}
```

### 4. Update Book Price

**PUT** `/books/<id>`

```json
{ "price": 25.00 }
```

### 5. Delete Author

**DELETE** `/authors/<id>`

* **Logic**: If an author is deleted, all their books should be deleted too (Cascade).

## Technical Constraints

1. **Service Layer**: Logic must exist in `services/author_service.py` and `services/book_service.py`. Routes must be thin.
2. **Migrations**: You must include a `migrations` folder generated by `flask db init`.
3. **Config**: Use `sqlite:///library.db`.

## Hints

### Model Relationships

Use the pattern from Level 2A:

```python
# models.py
class Author(db.Model):
    books = db.relationship('Book', backref='author', cascade='all, delete-orphan')

class Book(db.Model):
    author_id = db.Column(db.Integer, db.ForeignKey('authors.id'), nullable=False)
```

### Manual Serialization (No Nested Schemas Needed!)

For GET /authors/<id>, use manual serialization:

```python
@app.route('/authors/<int:id>', methods=['GET'])
def get_author(id):
    author = Author.query.get_or_404(id)
    
    return jsonify({
        "id": author.id,
        "name": author.name,
        "bio": author.bio,
        "books": [
            {"id": b.id, "title": b.title, "price": b.price} 
            for b in author.books
        ]
    }), 200
```

This avoids complex nested Marshmallow schemas while still returning the required format.

### Testing Cascade Delete

1. Create an author with 2 books
2. DELETE the author
3. Verify both books are also deleted (check database or try to GET the books)

## Expected Deliverables

* `app.py`
* `models.py`
* `services/`
* `migrations/`
* `requirements.txt`
