# Level 1: Flask Foundations - Routing & Requests

> **Prerequisites**: [Level 0: Beginner](01_LEVEL_0_BEGINNER.md)
> **Next Step**: [Test Task 1](03_TEST_TASK_1.md)

> [!NOTE]
> **No OOP Required**: We still use standard Python functions here. No classes needed!

## Goal

In this level, we will learn how to handle different types of requests, work with data sent by clients, and build well-structured APIs.

**Core Rules for this Level:**

1. **API First**: We only speak JSON.
2. **Thin Routes**: Routes should only parse input and return output.
3. **No Jinja**: We serve static HTML/JS if we need a UI.

## Table of Contents

1. [Routing Basics](#routing-basics)
2. [Handling Requests (The Input)](#handling-requests-the-input)
3. [Building Responses (The Output)](#building-responses-the-output)
4. [Serving Static Files](#serving-static-files)
5. [Pagination, Filtering, and Versioning](#pagination-filtering-and-versioning)
6. [Practice Problems](#practice-problems)

## Routing Basics

### 1. HTTP & API Basics

Before writing code, let's understand the request types and status codes we handle.

#### HTTP Methods

* **GET**: Retrieve data (Read). Browsers send this by default. **Never change data with a GET.**
* **POST**: Create new data (Create). Used for submitting forms or JSON.
* **PUT**: Update an existing resource completely (Replace).
* **PATCH**: Update parts of an existing resource (Modify).
* **DELETE**: Remove data (Delete).

#### HTTP Status Codes (The Response)

Always return the correct status code so the client knows what happened.

| Code | Meaning | Usage |
|------|---------|-------|
| 200 | OK | Standard success |
| 201 | Created | Resource created successfully |
| 400 | Bad Request | Client sent invalid JSON or missing fields |
| 404 | Not Found | Resource does not exist |
| 500 | Server Error | Something broke (Hide details from user!) |

### 2. How to Test (The Browser Trap)

> [!WARNING]
> **You cannot test POST requests in your browser address bar!**

When you type a URL in Chrome or Firefox, it **always** sends a `GET` request. If you try to visit a `POST`-only route, you will get a `405 Method Not Allowed` error.

**Tools you need:**

1. **Postman** (Recommended): A GUI app to send any type of HTTP request.
2. **cURL**: A command-line tool. Example: `curl -X POST http://localhost:5000/books`

### 3. Defining Routes

By default, a route only answers to GET. You must explicitly specify other methods.

```python
from flask import Flask, jsonify, request

app = Flask(__name__)

@app.route("/books", methods=["GET"])
def get_books():
    return jsonify({"message": "Get all books"})

@app.route("/books", methods=["POST"])
def create_book():
    return jsonify({"message": "Create a book"}), 201
```

> [!TIP]
> **Magic Box – Flask routing & `request`**: Treat `Flask(__name__)`, `@app.route`, `jsonify(...)`, and the `request` object as Magic Boxes. You mainly need to know *where* to read data (`request.get_json()`, `request.args`) and *what* JSON to return.

### 4. Complete Guide to HTTP Methods

Let's see all the HTTP methods with practical examples. We'll build a simple Book API to demonstrate each method.

#### GET - Retrieve Data

**Use when:** You want to read/fetch data without changing anything.

```python
# Get all books
@app.route("/books", methods=["GET"])
def get_books():
    books = [
        {"id": 1, "title": "Flask Guide", "author": "John Doe"},
        {"id": 2, "title": "Python Basics", "author": "Jane Smith"}
    ]
    return jsonify({"books": books}), 200

# Get a single book by ID
@app.route("/books/<int:book_id>", methods=["GET"])
def get_book(book_id):
    # In a real app, fetch from database
    book = {"id": book_id, "title": "Flask Guide", "author": "John Doe"}
    return jsonify(book), 200
```

**Key points:**

* GET requests **never** change data
* Query parameters (`?page=1&sort=title`) for filtering/pagination
* Always return 200 OK on success

#### POST - Create New Resource

**Use when:** You want to create a brand new resource.

```python
@app.route("/books", methods=["POST"])
def create_book():
    data = request.get_json()
    
    # Validation
    if not data or 'title' not in data or 'author' not in data:
        return jsonify({"error": "Missing title or author"}), 400
    
    # In a real app, save to database and get generated ID
    new_book = {
        "id": 123,  # Would be auto-generated by DB
        "title": data['title'],
        "author": data['author']
    }
    
    return jsonify({"message": "Book created", "book": new_book}), 201
```

**Key points:**

* Always return **201 Created** on success (not 200)
* Data comes from request body as JSON
* Generate/assign ID server-side (never trust client-provided IDs)

#### PUT - Replace Entire Resource

**Use when:** You want to completely replace an existing resource with new data.

```python
@app.route("/books/<int:book_id>", methods=["PUT"])
def update_book_full(book_id):
    data = request.get_json()
    
    # PUT requires ALL fields to be present
    if not data or 'title' not in data or 'author' not in data:
        return jsonify({"error": "PUT requires title AND author"}), 400
    
    # In a real app, check if book exists first
    # If not found: return 404
    
    # Replace the entire resource
    updated_book = {
        "id": book_id,
        "title": data['title'],
        "author": data['author']
    }
    
    return jsonify({"message": "Book replaced", "book": updated_book}), 200
```

**Key points:**

* **Replaces** the entire resource (all fields must be provided)
* Missing fields would be removed/set to defaults
* Return 404 if resource doesn't exist
* Return 200 OK on success

**Example:**

```json
// Before: {"id": 1, "title": "Old Title", "author": "Old Author", "year": 2020}
// PUT with: {"title": "New Title", "author": "New Author"}
// After: {"id": 1, "title": "New Title", "author": "New Author"}
// Notice: 'year' field is gone!
```

#### PATCH - Partial Update

**Use when:** You want to update only specific fields of a resource.

```python
@app.route("/books/<int:book_id>", methods=["PATCH"])
def update_book_partial(book_id):
    data = request.get_json()
    
    if not data:
        return jsonify({"error": "No data provided"}), 400
    
    # In a real app, fetch existing book from DB
    existing_book = {
        "id": book_id,
        "title": "Original Title",
        "author": "Original Author",
        "year": 2020
    }
    
    # Check if book exists
    # if not found: return 404
    
    # Update only the fields that were sent
    if 'title' in data:
        existing_book['title'] = data['title']
    if 'author' in data:
        existing_book['author'] = data['author']
    if 'year' in data:
        existing_book['year'] = data['year']
    
    return jsonify({"message": "Book updated", "book": existing_book}), 200
```

**Key points:**

* Only updates fields that are provided
* Other fields remain unchanged
* More flexible than PUT
* Most commonly used for updates in modern APIs

**Example:**

```json
// Before: {"id": 1, "title": "Old Title", "author": "Old Author", "year": 2020}
// PATCH with: {"title": "New Title"}
// After: {"id": 1, "title": "New Title", "author": "Old Author", "year": 2020}
// Notice: 'author' and 'year' are preserved!
```

#### DELETE - Remove Resource

**Use when:** You want to permanently remove a resource.

```python
@app.route("/books/<int:book_id>", methods=["DELETE"])
def delete_book(book_id):
    # In a real app, check if book exists
    # If not found: return 404
    
    # Delete from database
    # db.session.delete(book)
    # db.session.commit()
    
    return jsonify({"message": "Book deleted successfully"}), 200
```

**Alternative:** You can also return **204 No Content** with no response body:

```python
@app.route("/books/<int:book_id>", methods=["DELETE"])
def delete_book(book_id):
    # Delete logic here
    return '', 204  # No content
```

**Key points:**

* Return 200 OK with a message, **or** 204 No Content with empty body
* Return 404 if resource doesn't exist
* DELETE is **idempotent** (calling it multiple times has the same effect)

### 5. Quick Reference: When to Use Which Method

| Method | Purpose | Body Required | Idempotent* | Success Code |
|--------|---------|---------------|-------------|--------------|
| **GET** | Retrieve data | No | Yes | 200 |
| **POST** | Create new | Yes | No | 201 |
| **PUT** | Replace entire resource | Yes | Yes | 200 |
| **PATCH** | Update partial | Yes | No** | 200 |
| **DELETE** | Remove | No | Yes | 200 or 204 |

*Idempotent = calling it multiple times has the same effect as calling it once

**Common Mistakes to Avoid:**

1. ❌ Using GET to create/update/delete data
2. ❌ Using POST for updates (use PUT or PATCH)
3. ❌ Returning 200 OK when creating resources (use 201 Created)
4. ❌ Using PUT when you only want to update one field (use PATCH)

### Dynamic URLs

## Handling Requests (The Input)

In an API, we mostly care about **JSON Body** and **Query Parameters**.

### 1. JSON Body (POST/PUT)

Used when creating or updating resources.

```python
@app.route("/users", methods=["POST"])
def create_user():
    # request.get_json() parses the JSON body
    data = request.get_json()
    
    username = data.get("username")
    email = data.get("email")
    
    # In real app: Validate and Save to DB
    
    return jsonify({"status": "created", "username": username}), 201
```

### 3. The `request` Object Summary

Confused? Here is a cheat sheet:

| Data Source | Content-Type | Usage | Flask Accessor |
|-------------|--------------|-------|----------------|
| **JSON** | `application/json` | Modern APIs (POST/PUT) | `request.get_json()` |
| **URL Params** | N/A | Filtering/Sorting (GET) | `request.args.get('key')` |
| **Form Data** | `application/x-www-form-urlencoded` | HTML Forms | `request.form.get('key')` |
| **Path Vars** | N/A | Resource IDs | Function Argument |

### 4. Query Parameters (GET)

Used for filtering or pagination (e.g., `/users?page=2&role=admin`).

```python
@app.route("/users", methods=["GET"])
def list_users():
    # request.args is a dictionary-like object
    page = request.args.get("page", 1, type=int)
    role = request.args.get("role")
    
    return jsonify({"page": page, "filter_role": role})
```

## Building Responses (The Output)

Always return `jsonify` and a proper Status Code (see the table in [HTTP & API Basics](#1-http--api-basics)).

```python
@app.route("/orders", methods=["POST"])
def create_order():
    data = request.get_json()
    
    if not data or "item" not in data:
        # 400 Bad Request
        return jsonify({"error": "Missing 'item' field"}), 400
        
    return jsonify({"id": 123, "status": "pending"}), 201
```

## Error Handling and Status Codes

Proper error handling is **critical** for building production-ready APIs. This section prepares you for Test Task 1 and real-world development.

### Understanding HTTP Status Codes (Detailed)

We saw a brief table earlier. Now let's understand each error code with practical examples.

#### 200 OK - Success

**Use when:** The request succeeded and you're returning data.

```python
@app.route("/users/<int:user_id>", methods=["GET"])
def get_user(user_id):
    user = {"id": user_id, "name": "Alice"}
    return jsonify(user), 200
```

#### 201 Created - Resource Created

**Use when:** A new resource was successfully created.

```python
@app.route("/users", methods=["POST"])
def create_user():
    data = request.get_json()
    # Create logic here
    return jsonify({"id": 123, "name": data['name']}), 201
```

#### 400 Bad Request - Client Error

**Use when:** The client sent invalid/malformed data or missing required fields.

**Common scenarios:**

* Missing required fields
* Invalid JSON format
* Invalid data types
* Validation failures
* Invalid UUID/ID format

```python
@app.route("/users", methods=["POST"])
def create_user():
    data = request.get_json()
    
    # Scenario 1: No JSON body
    if not data:
        return jsonify({"error": "Request body is required"}), 400
    
    # Scenario 2: Missing required fields
    if 'name' not in data:
        return jsonify({"error": "Missing 'name' field"}), 400
    
    if 'email' not in data:
        return jsonify({"error": "Missing 'email' field"}), 400
    
    # Scenario 3: Invalid data type
    if not isinstance(data.get('age'), int):
        return jsonify({"error": "Age must be an integer"}), 400
    
    # Success
    return jsonify({"message": "User created"}), 201
```

**Example: Invalid UUID Format**

```python
import uuid

@app.route("/users/<user_id>", methods=["GET"])
def get_user(user_id):
    # Validate UUID format
    try:
        uuid.UUID(user_id)
    except ValueError:
        return jsonify({"error": "Invalid UUID format"}), 400
    
    # Proceed with valid UUID
    user = {"id": user_id, "name": "Alice"}
    return jsonify(user), 200
```

#### 404 Not Found - Resource Doesn't Exist

**Use when:** The requested resource (user, product, etc.) cannot be found.

```python
# Mock database
users = [
    {"id": "a1b2c3", "name": "Alice"},
    {"id": "d4e5f6", "name": "Bob"}
]

@app.route("/users/<user_id>", methods=["GET"])
def get_user(user_id):
    # Search for user
    user = next((u for u in users if u['id'] == user_id), None)
    
    if not user:
        return jsonify({"error": "User not found"}), 404
    
    return jsonify(user), 200
```

**DELETE example:**

```python
@app.route("/users/<user_id>", methods=["DELETE"])
def delete_user(user_id):
    user = next((u for u in users if u['id'] == user_id), None)
    
    if not user:
        return jsonify({"error": "User not found"}), 404
    
    users.remove(user)
    return jsonify({"message": "User deleted successfully"}), 200
```

#### 500 Internal Server Error - Something Went Wrong

**Use when:** An unexpected error occurs on the server (database crash, file system error, etc.).

> [!IMPORTANT]
> **Never expose internal error details to clients!** This is a security risk. Log the full error server-side, but return a generic message to the client.

```python
@app.route("/users", methods=["GET"])
def get_users():
    try:
        # Simulating file read that might fail
        with open("users.json", "r") as f:
            users = json.load(f)
        return jsonify({"users": users}), 200
    
    except FileNotFoundError:
        # Log the error internally
        print("ERROR: users.json not found!")
        
        # Return generic error to client
        return jsonify({"error": "Internal server error"}), 500
    
    except json.JSONDecodeError:
        print("ERROR: Invalid JSON in users.json")
        return jsonify({"error": "Internal server error"}), 500
```

### Handling Invalid JSON

When `request.get_json()` fails because the client sent malformed JSON:

```python
@app.route("/users", methods=["POST"])
def create_user():
    try:
        data = request.get_json()
    except Exception:
        return jsonify({"error": "Invalid JSON"}), 400
    
    if not data:
        return jsonify({"error": "Request body is required"}), 400
    
    # Process valid JSON
    return jsonify({"message": "User created"}), 201
```

**Better approach using Flask's built-in handling:**

```python
@app.route("/users", methods=["POST"])
def create_user():
    # Flask automatically returns 400 for malformed JSON if force=False (default)
    data = request.get_json()
    
    if data is None:
        return jsonify({"error": "Invalid or missing JSON"}), 400
    
    # Proceed with valid data
    return jsonify({"message": "User created"}), 201
```

### Complete Error Handling Example

Here's a complete example showing all the error handling patterns you've learned, using a product inventory system:

```python
from flask import Flask, jsonify, request
import json

app = Flask(__name__)

@app.route("/products/<int:product_id>", methods=["GET"])
def get_product(product_id):
    # Error 1: Validate product_id is positive
    if product_id <= 0:
        return jsonify({"error": "Invalid product ID"}), 400
    
    # Error 2: Load products from file
    try:
        with open("inventory.json", "r") as f:
            data = json.load(f)
            products = data.get("products", [])
    except FileNotFoundError:
        return jsonify({"error": "Internal server error"}), 500
    except json.JSONDecodeError:
        return jsonify({"error": "Internal server error"}), 500
    
    # Error 3: Product not found
    product = next((p for p in products if p['id'] == product_id), None)
    if not product:
        return jsonify({"error": "Product not found"}), 404
    
    # Success
    return jsonify(product), 200


@app.route("/products", methods=["POST"])
def create_product():
    data = request.get_json()
    
    # Error 1: No data
    if not data:
        return jsonify({"error": "Request body required"}), 400
    
    # Error 2: Missing required fields
    if 'name' not in data or 'price' not in data:
        return jsonify({"error": "Missing name or price"}), 400
    
    # Error 3: Invalid data type
    if not isinstance(data['price'], (int, float)) or data['price'] < 0:
        return jsonify({"error": "Price must be a positive number"}), 400
    
    # Success - create product
    new_product = {
        "id": 123,  # Would be generated
        "name": data['name'],
        "price": data['price']
    }
    return jsonify(new_product), 201
```

**This example demonstrates:**

* Validation errors (400)
* File operation errors (500)
* Resource not found errors (404)
* Proper try-except blocks
* Clean error messages

You can apply these same patterns to any API you build, including Test Task 1!

### Using Try-Except Blocks Effectively

**Pattern for file operations:**

```python
try:
    with open("data.json", "r") as f:
        data = json.load(f)
except FileNotFoundError:
    # File doesn't exist - maybe first run
    data = {"users": []}
except json.JSONDecodeError:
    # File is corrupted
    return jsonify({"error": "Internal server error"}), 500
except Exception as e:
    # Unexpected error
    print(f"Unexpected error: {e}")
    return jsonify({"error": "Internal server error"}), 500
```

**Pattern for validation:**

```python
def validate_user_data(data):
    """Helper function to validate user data. Returns error message or None."""
    if not data:
        return "Request body is required"
    
    if 'name' not in data:
        return "Missing 'name' field"
    
    if 'email' not in data:
        return "Missing 'email' field"
    
    if 'age' in data and not isinstance(data['age'], int):
        return "Age must be an integer"
    
    return None  # No errors

@app.route("/users", methods=["POST"])
def create_user():
    data = request.get_json()
    
    error = validate_user_data(data)
    if error:
        return jsonify({"error": error}), 400
    
    # Proceed with valid data
    return jsonify({"message": "User created"}), 201
```

### Quick Reference: Error Handling Checklist

Before submitting Test Task 1, ensure you handle:

* [ ] **400**: Missing request body
* [ ] **400**: Missing required fields
* [ ] **400**: Invalid JSON format
* [ ] **400**: Invalid UUID format (for URL parameters)
* [ ] **404**: User/resource not found
* [ ] **500**: File read/write errors
* [ ] **500**: Unexpected exceptions

### Common Mistakes to Avoid

1. ❌ **Exposing internal errors**

   ```python
   # BAD - Don't do this!
   return jsonify({"error": str(exception)}), 500
   ```

2. ❌ **Not validating required fields**

   ```python
   # BAD - Will crash if 'name' is missing
   name = data['name']
   ```

3. ❌ **Using wrong status codes**

   ```python
   # BAD - Resource created should be 201, not 200
   return jsonify({"message": "Created"}), 200
   ```

4. ❌ **Not handling file operations safely**

   ```python
   # BAD - What if file doesn't exist?
   data = json.load(open("users.json"))
   ```

## Serving Static Files

Since we **do not use Jinja templates**, we handle UI by serving static HTML/JS files that consume our JSON API.

Place files in a `static` folder:

```
project/
├── static/
│   ├── index.html
│   └── app.js
└── app.py
```

### Serving the Entry Point

```python
@app.route("/")
def index():
    # Send the static index.html file
    return app.send_static_file("index.html")
```

Your `index.html` should use JavaScript (`fetch` or `axios`) to call your API endpoints (e.g., `/users`) and display data.

## Pagination, Filtering, and Versioning

At some point your API will outgrow simple “return all rows” endpoints. You need a consistent way to **page**, **filter**, and **version** your APIs.

### 1. Basic pagination pattern

Use `page` and `page_size` (or `limit` and `offset`) as query parameters:

```python
@app.route("/items", methods=["GET"])
def list_items():
    page = request.args.get("page", 1, type=int)
    page_size = request.args.get("page_size", 20, type=int)

    # pretend this comes from your DB
    items = [
        {"id": 1, "name": "Item 1"},
        {"id": 2, "name": "Item 2"},
    ]

    return jsonify({
        "items": items,
        "page": page,
        "page_size": page_size,
        "total": len(items),
    })
```

Recommended response envelope:

* `items`: list of resources
* `page`: current page
* `page_size`: how many per page
* `total`: total number of items

### 2. Filtering and searching

Reuse query params for filters instead of inventing custom URLs:

* `/users?role=admin`
* `/books?author_id=1&price_min=10&price_max=50`

Example:

```python
@app.route("/books", methods=["GET"])
def list_books():
    author_id = request.args.get("author_id", type=int)
    price_min = request.args.get("price_min", type=float)
    price_max = request.args.get("price_max", type=float)

    return jsonify({
        "author_id": author_id,
        "price_min": price_min,
        "price_max": price_max,
    })
```

### 3. API versioning

When you need to introduce **breaking changes**, do not silently change existing URLs. Add a version prefix:

* `/api/v1/books`
* `/api/v2/books`

Later levels and Test Task 3 use prefixes like `/api/v1/authors` and `/api/v1/books`. You should follow the same idea in your own projects.

## Practice Problems

### Problem 1: Calculator API

Create an endpoint `/calculate` that accepts a POST request with JSON:
`{"operation": "add", "x": 10, "y": 5}`
And returns: `{"result": 15}`.
Support add, subtract, multiply, divide. Return 400 for invalid operations.

### Problem 3: Query Params

Create a route `/search` that takes a query param `q`. If `q` is missing, return error 400. If present, return `{"query": q}`.

## Trivia

### Question 1

**How do you access the JSON body sent by a client?**

* [ ] `request.body`
* [x] `request.get_json()`
* [ ] `request.json_data`
* [ ] `json.load(request)`

### Question 3

**If a client sends invalid data, what status code should you return?**

* [ ] 200 OK
* [ ] 500 Server Error
* [x] 400 Bad Request
* [ ] 404 Not Found
