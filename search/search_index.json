{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Flask Learning Guide","text":"<p>[!CAUTION] Read All Code Carefully Before Copy-Pasting</p> <p>This documentation is designed to teach you proper debugging skills. Some code examples may contain intentional mistakes that you must identify and fix using the debugging techniques taught in Level 0.</p> <p>Always:</p> <ul> <li>Read the entire code example before copying</li> <li>Understand what each line does</li> <li>Test your code and debug any errors</li> <li>Use the Flask debugger when things break</li> </ul> <p>Blindly copy-pasting code will lead to errors. This is intentional. Debugging is a core skill.</p>"},{"location":"index.html#welcome","title":"Welcome! \ud83d\udc4b","text":"<p>This comprehensive guide will take you from a complete beginner to an expert in Flask. Whether you're new to Python web development or have some experience, this structured learning path will help you master building scalable, RESTful APIs with Flask.</p>"},{"location":"index.html#learning-path-overview","title":"\ud83d\udcda Learning Path Overview","text":"<p>This guide is divided into 7 levels (including sub-levels), each building upon the previous one. We focus strictly on building APIs (no HTML templates).</p> <ul> <li>Level 0: Complete Beginner - Python basics, web concepts, and environment setup</li> <li>Level 1: Foundations - Routing, JSON handling, and Request methods</li> <li>Level 2A: Databases - SQLAlchemy, Migrations, and the Service Layer</li> <li>Level 2B: Serialization - Marshmallow Schemas and Global Error Handling</li> <li>Level 3: Authentication - JWTs, Security, and Password Hashing</li> <li>Level 4: Scalable - Application Factory, Blueprints, and Circular Imports</li> </ul>"},{"location":"index.html#phases-overview-oop-expectations","title":"Phases Overview (OOP Expectations)","text":"<p>To keep things beginner-friendly, the Flask track is split into phases with clear expectations about Object-Oriented Programming (OOP):</p> <ul> <li>Phase 1 \u2013 Levels 0\u20131 (No OOP Required)   You only write functions. You do not need to know or use <code>class</code> at all.</li> <li>Phase 2 \u2013 Levels 2\u20134 (Light <code>class</code> Usage)   We use <code>class</code> mainly for models, schemas, and services as namespaces / configuration. You can treat them as patterns and Magic Boxes and still succeed without deep OOP theory.</li> </ul>"},{"location":"index.html#time-estimates","title":"\u23f1\ufe0f Time Estimates","text":"Level Estimated Time Difficulty Level 0 2-3 hours \u2b50 Beginner Level 1 5-8 hours \u2b50 Beginner Level 2A 8-12 hours \u2b50\u2b50 Intermediate Level 2B 5-8 hours \u2b50\u2b50 Intermediate Level 3 10-15 hours \u2b50\u2b50\u2b50 Advanced Level 4 8-12 hours \u2b50\u2b50\u2b50 Advanced <p>Total Estimated Time: 40-60 hours (approximately 1-2 months of part-time study)</p>"},{"location":"index.html#prerequisites","title":"\ud83d\udccb Prerequisites","text":""},{"location":"index.html#required-knowledge","title":"Required Knowledge","text":"<p>Before starting Level 0, you should have:</p> <ul> <li>\u2705 Basic Python knowledge:</li> <li>Variables, dictionaries, lists</li> <li>Functions and decorators (helpful but we explain them)</li> <li> <p>Modules and imports</p> </li> <li> <p>\u2705 Command line basics:</p> </li> <li><code>cd</code>, <code>ls</code>, <code>mkdir</code></li> <li>Running scripts (<code>python app.py</code>)</li> </ul>"},{"location":"index.html#optional-helpful","title":"Optional (Helpful)","text":"<ul> <li>Understanding of HTTP (GET vs POST)</li> <li>JSON syntax</li> </ul>"},{"location":"index.html#faq-do-i-need-to-know-object-oriented-programming-oop","title":"\u2753 FAQ: Do I need to know Object-Oriented Programming (OOP)?","text":"<p>Short Answer: No.</p> <p>Many beginners get stuck because they think they need to master Classes and Objects before learning Flask. You do not.</p> <ul> <li>Phase 1 (Levels 0-1): Purely functional. You write functions. No OOP knowledge is required.</li> <li>Phase 2 (Levels 2-4): We use <code>class</code> keywords, but only as \"containers\", namespaces, or configuration. You rarely write complex OOP logic.</li> </ul> <p>[!TIP] We have added specific notes in each level to explain exactly what you need to know about classes, so you never feel lost. When in doubt, glance at the Phases Overview above and the Classes as Namespaces section in Level 2A.</p>"},{"location":"index.html#faq-classes-objects-and-when-to-care","title":"FAQ: Classes, Objects, and When to Care","text":"<ul> <li> <p>Do I need to understand classes before starting Level 0?   No. You can complete Phase 1 (Levels 0\u20131) using only functions and modules.</p> </li> <li> <p>When will I actually need OOP knowledge?   Mainly when you want to go beyond this track and design more advanced architectures (custom domain models, inheritance, interfaces). You can safely finish Levels 0\u20134 first.</p> </li> <li> <p>What does <code>class UserService</code> really mean in this course?   It is just a namespace (a folder for related functions). You typically call <code>UserService.create_user(...)</code> without worrying about constructing objects or writing <code>__init__</code> methods.</p> </li> </ul>"},{"location":"index.html#how-to-use-this-guide","title":"\ud83c\udfaf How to Use This Guide","text":""},{"location":"index.html#step-by-step-approach","title":"Step-by-Step Approach","text":"<ol> <li>Start sequentially: Do not skip Level 0 or 1. They lay the foundation.</li> <li>STOP at Checkpoints: There are 3 Test Tasks. You must complete them before moving on. They are the gatekeepers.<ul> <li>Test Task 1 (After Level 1)</li> <li>Test Task 2 (After Level 3)</li> <li>Test Task 3 (After Level 4)</li> </ul> </li> <li>Code Along: Reading is not enough. Type the code.</li> </ol>"},{"location":"index.html#tools-youll-need","title":"\ud83d\udee0\ufe0f Tools You'll Need","text":"<ol> <li>Python 3.8+</li> <li>Code Editor (VS Code recommended)</li> <li>Postman (Essential for testing APIs. Browser is not enough!)</li> <li>DB Browser for SQLite (Optional, for visualizing the DB)</li> </ol>"},{"location":"index.html#magic-boxes-what-you-can-ignore-for-now","title":"\ud83e\uddf0 Magic Boxes (What You Can Ignore for Now)","text":"<p>Some libraries and patterns in this course are Magic Boxes: you can use them confidently without fully understanding their internals yet.</p> <p>Examples of Magic Boxes in this track:</p> <ul> <li><code>Flask</code> itself (<code>Flask(__name__)</code>, <code>@app.route</code>)</li> <li>Database layer: <code>SQLAlchemy</code>, <code>Flask-Migrate</code></li> <li>Serialization and validation: <code>Flask-Marshmallow</code>, <code>Marshmallow</code></li> <li>Auth tooling: <code>flask-bcrypt</code>, <code>flask-jwt-extended</code></li> </ul> <p>[!TIP] When you see a Magic Box callout in the levels, it means: \u201cFocus on how to use it; you do not need to understand how it works internally yet.\u201d</p> <p>You can also refer to the Pattern Cheatsheet (<code>PATTERN_CHEATSHEET.md</code>) at any time for small, copy-pastable examples of how these pieces fit together.</p>"},{"location":"index.html#guide-structure","title":"\ud83d\udcd6 Guide Structure","text":""},{"location":"index.html#phase-1-the-basics-json-http","title":"Phase 1: The Basics (JSON &amp; HTTP)","text":"<ul> <li>Level 0: Beginner: Setup, Environment, Hello World. (No OOP required.)</li> <li>Level 1: Foundations: Routing, JSON Handling, Request Methods. (No OOP required.)</li> </ul> <p>[!IMPORTANT] Checkpoint: Complete Test Task 1 before moving forward.</p>"},{"location":"index.html#phase-2-intermediate-data-logic","title":"Phase 2: Intermediate (Data &amp; Logic)","text":"<ul> <li>Level 2A: Databases: SQLAlchemy, Migrations, Service Layer. (Light <code>class</code> usage as namespaces and configuration.)</li> <li>Level 2B: Serialization: Marshmallow Schemas, Error Handling. (Schemas are template-like classes; OOP knowledge is optional.)</li> <li>Level 3: Authentication: JWTs, Securing Endpoints. (Security-focused; classes used as thin helpers and services.)</li> </ul> <p>[!IMPORTANT] Checkpoint: Complete Test Task 2 (Library API) before moving forward.</p>"},{"location":"index.html#phase-3-advanced-architecture","title":"Phase 3: Advanced Architecture","text":"<ul> <li>Level 4: Scalable Structure: Blueprints, Application Factory, Solving Circular Imports. (Focus on project structure and imports, not deep OOP.)</li> </ul> <p>[!IMPORTANT] Checkpoint: Complete Test Task 3 (Refactor to Scalable App).</p>"},{"location":"index.html#troubleshooting-common-issues","title":"\ud83d\udc1b Troubleshooting Common Issues","text":""},{"location":"index.html#1-method-not-allowed-405-error","title":"1. \"Method Not Allowed\" (405 Error)","text":"<ul> <li>Cause: You tried to access a POST route via the browser address bar (which uses GET).</li> <li>Fix: Use Postman or <code>curl</code> to send the correct method.</li> </ul>"},{"location":"index.html#2-circular-import-error","title":"2. \"Circular Import Error\"","text":"<ul> <li>Cause: <code>app.py</code> imports <code>models</code>, and <code>models</code> imports <code>app</code> (to get <code>db</code>).</li> <li>Fix: See Level 4 (The Application Factory &amp; Extensions pattern). Move <code>db</code> to <code>extensions.py</code>.</li> </ul>"},{"location":"index.html#3-runtimeerror-working-outside-of-application-context","title":"3. \"RuntimeError: Working outside of application context\"","text":"<ul> <li>Cause: You tried to access <code>current_app</code> or <code>db</code> without an active request or app context.</li> <li>Fix: Wrap your code in <code>with app.app_context():</code>.</li> </ul>"},{"location":"index.html#4-attributeerror-function-object-has-no-attribute","title":"4. \"AttributeError: 'function' object has no attribute...\"","text":"<ul> <li>Cause: You might be trying to access a property on a function instead of a class instance, or vice versa.</li> <li>Fix: Check if you are using <code>self.variable</code> inside a <code>class</code> method, or just <code>variable</code> inside a standard function.</li> </ul>"},{"location":"index.html#common-class-related-errors-beginner-edition","title":"Common Class-Related Errors (Beginner Edition)","text":"<ul> <li> <p><code>AttributeError: 'function' object has no attribute '...'</code>   Usually means you treated a function like an object. Example: calling <code>user_service.create_user(...)</code> when <code>user_service</code> is a function, or forgetting to import <code>UserService</code> correctly.</p> </li> <li> <p><code>TypeError: create_user() missing 1 required positional argument: 'self'</code>   This often appears if you define a method on a class without <code>@staticmethod</code> but call it like <code>UserService.create_user(...)</code>. In this course, we almost always mark service methods as <code>@staticmethod</code> so you never need <code>self</code>.</p> </li> <li> <p>Import-related <code>NameError</code> for classes like <code>UserService</code> or <code>AuthService</code>   Usually a sign the import path is wrong or there is a circular import. Double-check you are importing from <code>services.user_service</code> or <code>services.auth_service</code>, and see Level 4 for how <code>extensions.py</code> helps avoid circular imports.</p> </li> </ul>"},{"location":"index.html#progress-checklist","title":"\u2705 Progress Checklist","text":"<ul> <li>[ ] Level 0: Setup (no OOP)</li> <li>[ ] Hello World works</li> <li> <p>[ ] <code>jsonify</code> understood</p> </li> <li> <p>[ ] Level 1: Requests (no OOP)</p> </li> <li>[ ] Query Params vs JSON Body</li> <li>[ ] Postman installed and working</li> <li> <p>[ ] Test Task 1 Completed</p> </li> <li> <p>[ ] Level 2: Data (light classes as namespaces/config)</p> </li> <li>[ ] Connected to SQLite</li> <li>[ ] Migrations run successfully</li> <li>[ ] Service Layer created (No DB calls in routes!)</li> <li> <p>[ ] Marshmallow schemas defined</p> </li> <li> <p>[ ] Level 3: Security (Magic Box heavy, OOP optional)</p> </li> <li>[ ] Passwords hashed (Bcrypt)</li> <li>[ ] JWTs working</li> <li> <p>[ ] Test Task 2 Completed</p> </li> <li> <p>[ ] Level 4: Architecture (classes as patterns and configuration)</p> </li> <li>[ ] App Factory implemented</li> <li>[ ] Blueprints set up</li> <li>[ ] Test Task 3 Completed</li> </ul>"},{"location":"index.html#ready-to-start","title":"\ud83d\ude80 Ready to Start?","text":"<p>Begin your journey with Level 0: Beginner!</p> <p>Good luck! \ud83d\udc0d</p>"},{"location":"01_LEVEL_0_BEGINNER.html","title":"Level 0: Complete Beginner - Python &amp; Web Fundamentals for Flask","text":"<p>Prerequisites: None. This is where your journey begins! Next Level: Level 1: Foundations</p> <p>[!NOTE] No OOP Required: You do not need to know about Python Classes or Objects to start this level. We use simple functions.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#goal","title":"Goal","text":"<p>Before diving into Flask, you need to understand the fundamentals. This level covers Python basics for web development, web concepts, and environment setup. By the end, you'll be ready to start building your first Flask API.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#table-of-contents","title":"Table of Contents","text":"<ol> <li>Why Learn This?</li> <li>Python Basics for Web Development</li> <li>Understanding the Web</li> <li>What is an API?</li> <li>Environment Setup Explained</li> <li>Hello World: Your First Flask API</li> <li>Practice Problems</li> <li>Trivia</li> </ol>"},{"location":"01_LEVEL_0_BEGINNER.html#why-learn-this","title":"Why Learn This?","text":""},{"location":"01_LEVEL_0_BEGINNER.html#what-is-flask","title":"What is Flask?","text":"<p>Flask is a lightweight WSGI web application framework. It is designed to make getting started quick and easy, with the ability to scale up to complex applications. It began as a simple wrapper around Werkzeug and Jinja and has become one of the most popular Python web application frameworks.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#why-use-flask","title":"Why Use Flask?","text":"<ul> <li>Flexible: It gives you control over how you structure your application.</li> <li>Minimalistic: Core is simple and extensible.</li> <li>Great for APIs: Perfect for building RESTful services (our focus).</li> <li>Industry Standard: Used by companies like Netflix, Lyft, and Reddit.</li> </ul>"},{"location":"01_LEVEL_0_BEGINNER.html#python-basics-for-web-development","title":"Python Basics for Web Development","text":""},{"location":"01_LEVEL_0_BEGINNER.html#variables-and-json-structures","title":"Variables and JSON Structures","text":"<p>Why this matters: We will be building APIs that speak JSON. Python dictionaries are the closest relative to JSON.</p> <pre><code># Dictionaries - The core of our API responses\nuser = {\n    \"id\": 1,\n    \"username\": \"dev_user\",\n    \"is_active\": True,\n    \"roles\": [\"admin\", \"editor\"]\n}\n\n# Lists - Collections of resources\nusers = [\n    {\"id\": 1, \"username\": \"dev_user\"},\n    {\"id\": 2, \"username\": \"test_user\"}\n]\n</code></pre>"},{"location":"01_LEVEL_0_BEGINNER.html#functions-as-endpoints","title":"Functions as Endpoints","text":"<p>Why this matters: In Flask, a \"route\" is just a function decorated with a URL path.</p> <pre><code># A normal function\ndef get_user_data(user_id):\n    return {\"id\": user_id, \"name\": \"Alice\"}\n\n# In Flask, it looks very similar:\n# @app.route(\"/users/&lt;int:user_id&gt;\")\n# def get_user(user_id):\n#     return {\"id\": user_id, \"name\": \"Alice\"}\n</code></pre>"},{"location":"01_LEVEL_0_BEGINNER.html#understanding-the-web","title":"Understanding the Web","text":""},{"location":"01_LEVEL_0_BEGINNER.html#client-server-model","title":"Client-Server Model","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         HTTP Request          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client  \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; \u2502 Server \u2502\n\u2502(Browser)\u2502                                \u2502(Flask) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 &lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            HTTP Response (JSON)\n</code></pre> <p>Key Concept: In this course, we are building APIs. We will not be sending HTML pages (templates). We will send JSON data. The Client (Front-end or Mobile App) will take that JSON and display it.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#what-is-an-api","title":"What is an API?","text":"<p>API (Application Programming Interface) is the messenger that takes requests and tells a system what you want to do and then returns the response back to you.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#rest-api-basics","title":"REST API Basics","text":"<ul> <li>Resource: The \"thing\" you are interacting with (e.g., <code>User</code>, <code>Product</code>).</li> <li>Endpoint: The URL where the resource lives (e.g., <code>/api/users</code>).</li> <li>Method: The action (GET, POST, PUT, DELETE).</li> </ul>"},{"location":"01_LEVEL_0_BEGINNER.html#environment-setup-explained","title":"Environment Setup Explained","text":""},{"location":"01_LEVEL_0_BEGINNER.html#step-1-create-project-folder","title":"Step 1: Create Project Folder","text":"<pre><code>mkdir flask_learning\ncd flask_learning\n</code></pre>"},{"location":"01_LEVEL_0_BEGINNER.html#step-2-create-virtual-environment","title":"Step 2: Create Virtual Environment","text":"<p>Always use a virtual environment to isolate dependencies.</p> <p>Windows:</p> <pre><code>python -m venv venv\nvenv\\Scripts\\activate\n</code></pre> <p>Linux/Mac:</p> <pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre>"},{"location":"01_LEVEL_0_BEGINNER.html#step-3-install-flask","title":"Step 3: Install Flask","text":"<pre><code>pip install flask\n</code></pre>"},{"location":"01_LEVEL_0_BEGINNER.html#hello-world-your-first-flask-api","title":"Hello World: Your First Flask API","text":"<p>Let's create a minimal Flask application that returns JSON.</p> <ol> <li>Create a file named <code>app.py</code>.</li> <li>Add the following code:</li> </ol> <pre><code>from flask import Flask, jsonify\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef home():\n    \"\"\"\n    Root endpoint.\n    Returns a simple JSON message.\n    \"\"\"\n    return jsonify({\n        \"message\": \"Welcome to the Flask API!\",\n        \"status\": \"success\"\n    })\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre> <p>[!TIP] Magic Box \u2013 Flask &amp; <code>jsonify</code>: You do not need to understand how <code>Flask</code>, <code>@app.route</code>, or <code>jsonify</code> work internally yet. Treat this pattern as a reusable starting point and focus on the JSON you return.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#understanding-flask-basics","title":"Understanding Flask Basics","text":"<p>Before we run the application, let's understand what's happening in those last two lines.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#why-if-__name__-__main__","title":"Why <code>if __name__ == \"__main__\":</code>?","text":"<p>This is a standard Python pattern. Here's what it means:</p> <pre><code>if __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre> <p>Explanation:</p> <ul> <li><code>__name__</code> is a special Python variable. When you run a file directly (e.g., <code>python app.py</code>), Python sets <code>__name__</code> to <code>\"__main__\"</code>.</li> <li>If you import this file from another file (e.g., <code>from app import app</code>), then <code>__name__</code> will be the module name (<code>\"app\"</code>), not <code>\"__main__\"</code>.</li> </ul> <p>Why does this matter?</p> <p>We only want to start the Flask development server when we run the file directly, not when we import it. This is important because:</p> <ol> <li>Testing: When you write tests, you import your app without running the server.</li> <li>Production: Production servers (like Gunicorn or uWSGI) import your app and run it their own way.</li> </ol> <p>In simple terms: This line says \"Only start the development server if this file is being run directly.\"</p>"},{"location":"01_LEVEL_0_BEGINNER.html#understanding-apprun-parameters","title":"Understanding <code>app.run()</code> Parameters","text":"<p>The <code>app.run()</code> method starts Flask's built-in development server. Here are the most important parameters:</p> <pre><code>app.run(\n    host='127.0.0.1',  # What network interface to bind to\n    port=5000,         # What port to listen on\n    debug=True         # Enable/disable debug mode\n)\n</code></pre>"},{"location":"01_LEVEL_0_BEGINNER.html#1-host-network-interface","title":"1. <code>host</code> - Network Interface","text":"<p>Default: <code>'127.0.0.1'</code> (localhost only)</p> <pre><code># Only accessible from your own computer\napp.run(host='127.0.0.1')  # or just 'localhost'\n\n# Accessible from other devices on your network (e.g., testing on your phone)\napp.run(host='0.0.0.0')\n</code></pre> <p>[!WARNING] Security: Only use <code>host='0.0.0.0'</code> in development on trusted networks. Never in production!</p> <p>When to use each:</p> <ul> <li><code>127.0.0.1</code> (default): Development on your own machine only</li> <li><code>0.0.0.0</code>: Testing from other devices (phone, tablet) on your local network</li> </ul>"},{"location":"01_LEVEL_0_BEGINNER.html#2-port-port-number","title":"2. <code>port</code> - Port Number","text":"<p>Default: <code>5000</code></p> <pre><code># Use default port 5000\napp.run()  # Accessible at http://127.0.0.1:5000\n\n# Use custom port\napp.run(port=8080)  # Accessible at http://127.0.0.1:8080\n</code></pre> <p>Why change the port?</p> <ul> <li>Port 5000 is already in use by another application</li> <li>Your company/project has a standard port number</li> <li>You're running multiple Flask apps simultaneously</li> </ul>"},{"location":"01_LEVEL_0_BEGINNER.html#3-debug-debug-mode","title":"3. <code>debug</code> - Debug Mode","text":"<p>Default: <code>False</code> (disabled)</p> <pre><code># Development: Enable debug mode\napp.run(debug=True)\n\n# Production: NEVER enable debug mode\napp.run(debug=False)\n</code></pre> <p>What does <code>debug=True</code> do?</p> Feature Behavior Auto-reload Server restarts automatically when you change code Error Details Shows detailed error pages with stack traces in browser Interactive Debugger Allows you to inspect variables in the browser when errors occur <p>[!CAUTION] NEVER use <code>debug=True</code> in production! It exposes sensitive information and allows code execution through the browser debugger. This is a major security risk.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#complete-example-with-all-parameters","title":"Complete Example with All Parameters","text":"<pre><code>from flask import Flask, jsonify\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef home():\n    return jsonify({\"message\": \"Hello, Flask!\"})\n\nif __name__ == \"__main__\":\n    # Development configuration\n    app.run(\n        host='127.0.0.1',  # Localhost only\n        port=5000,          # Default Flask port\n        debug=True          # Enable auto-reload and detailed errors\n    )\n</code></pre>"},{"location":"01_LEVEL_0_BEGINNER.html#development-vs-production","title":"Development vs Production","text":"<p>Development (what we use in this course):</p> <pre><code>if __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre> <p>Production (real-world deployment):</p> <pre><code># Use a production server like Gunicorn\ngunicorn -w 4 -b 0.0.0.0:8000 app:app\n</code></pre> <p>[!NOTE] Flask's built-in server (<code>app.run()</code>) is only for development. For production, you need a proper WSGI server like Gunicorn, uWSGI, or Waitress. We'll cover this in later levels.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#run-it","title":"Run it","text":"<pre><code>python app.py\n</code></pre>"},{"location":"01_LEVEL_0_BEGINNER.html#test-it","title":"Test it","text":"<p>Open your browser or Postman and go to <code>http://127.0.0.1:5000/</code>.</p> <p>You should see:</p> <pre><code>{\n  \"message\": \"Welcome to the Flask API!\",\n  \"status\": \"success\"\n}\n</code></pre> <p>Note: Notice we used <code>jsonify</code>. This is a helper that converts Python dictionaries to proper JSON responses with the correct Content-Type header (<code>application/json</code>). Rule: Always return JSON. Never return raw strings or HTML for APIs.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#the-flask-debugger-your-best-friend","title":"The Flask Debugger: Your Best Friend","text":"<p>Before you start building real applications, you need to know how to debug when things go wrong. The Flask debugger is an incredibly powerful tool that will save you hours of frustration.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#what-is-the-flask-debugger","title":"What is the Flask Debugger?","text":"<p>When you set <code>debug=True</code>, Flask activates several helpful features:</p> <ol> <li>Auto-reload: Server restarts when you change code</li> <li>Detailed error pages: Shows exactly where errors occur</li> <li>Interactive debugger: Lets you inspect variables and run Python code in your browser when errors happen</li> </ol> <p>[!CAUTION] NEVER use <code>debug=True</code> in production! The interactive debugger allows anyone to execute Python code on your server. This is a critical security vulnerability.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#triggering-the-debugger","title":"Triggering the Debugger","text":"<p>Let's see the debugger in action by creating an intentional error.</p> <p>Step 1: Create a route with an error</p> <pre><code>from flask import Flask, jsonify\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef home():\n    return jsonify({\"message\": \"Hello, Flask!\"})\n\n@app.route(\"/broken\")\ndef broken_endpoint():\n    # This will cause an error\n    numbers = [1, 2, 3]\n    result = numbers[10]  # IndexError: list index out of range\n    return jsonify({\"result\": result})\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre> <p>Step 2: Run your app and visit the broken endpoint</p> <pre><code>python app.py\n</code></pre> <p>Navigate to <code>http://127.0.0.1:5000/broken</code> in your browser.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#understanding-the-error-page","title":"Understanding the Error Page","text":"<p>When the error occurs, you'll see a detailed error page with:</p> <ol> <li>The error type and message: <code>IndexError: list index out of range</code></li> <li>The traceback: Shows the exact line where the error occurred</li> <li>Interactive console: A small terminal icon next to each stack frame</li> </ol>"},{"location":"01_LEVEL_0_BEGINNER.html#using-the-interactive-console","title":"Using the Interactive Console","text":"<p>This is where the magic happens:</p> <ol> <li>Click the terminal icon next to any line in the traceback</li> <li>A console appears where you can type Python code</li> <li>Inspect variables: Type <code>numbers</code> to see <code>[1, 2, 3]</code></li> <li>Test fixes: Try <code>numbers[0]</code> to see what would work</li> </ol> <p>Example interaction:</p> <pre><code>&gt;&gt;&gt; numbers\n[1, 2, 3]\n&gt;&gt;&gt; len(numbers)\n3\n&gt;&gt;&gt; numbers[2]  # This works\n3\n&gt;&gt;&gt; numbers[10]  # This is what caused the error\nTraceback (most recent call last):\n  ...\nIndexError: list index out of range\n</code></pre>"},{"location":"01_LEVEL_0_BEGINNER.html#common-debugging-scenarios","title":"Common Debugging Scenarios","text":""},{"location":"01_LEVEL_0_BEGINNER.html#scenario-1-variable-not-what-you-expected","title":"Scenario 1: Variable Not What You Expected","text":"<pre><code>@app.route(\"/calculate\", methods=[\"POST\"])\ndef calculate():\n    data = request.get_json()\n    result = data[\"x\"] + data[\"y\"]  # Error if x or y is string\n    return jsonify({\"result\": result})\n</code></pre> <p>If this errors, use the debugger to check:</p> <ul> <li><code>data</code> - Is it a dict or None?</li> <li><code>data[\"x\"]</code> - Is it a number or a string?</li> <li><code>type(data[\"x\"])</code> - Confirm the type</li> </ul>"},{"location":"01_LEVEL_0_BEGINNER.html#scenario-2-understanding-data-flow","title":"Scenario 2: Understanding Data Flow","text":"<pre><code>@app.route(\"/users/&lt;int:user_id&gt;\")\ndef get_user(user_id):\n    users = [{\"id\": 1, \"name\": \"Alice\"}, {\"id\": 2, \"name\": \"Bob\"}]\n    user = next((u for u in users if u[\"id\"] == user_id), None)\n    # What if user is None?\n    return jsonify({\"name\": user[\"name\"]})  # Error if user is None\n</code></pre> <p>In the debugger:</p> <ul> <li>Check <code>user_id</code> value</li> <li>Check <code>user</code> - Is it None or a dict?</li> <li>Test the fix: <code>user[\"name\"] if user else \"Not Found\"</code></li> </ul>"},{"location":"01_LEVEL_0_BEGINNER.html#debug-mode-best-practices","title":"Debug Mode Best Practices","text":"<p>DO:</p> <ul> <li>\u2705 Use <code>debug=True</code> during development</li> <li>\u2705 Read the full traceback from bottom to top</li> <li>\u2705 Use the interactive console to test fixes</li> <li>\u2705 Check variable types and values when confused</li> </ul> <p>DON'T:</p> <ul> <li>\u274c Leave <code>debug=True</code> in production</li> <li>\u274c Ignore error messages - they tell you exactly what's wrong</li> <li>\u274c Skip reading the traceback</li> <li>\u274c Expose the debugger to the internet</li> </ul>"},{"location":"01_LEVEL_0_BEGINNER.html#debugging-without-the-interactive-debugger","title":"Debugging Without the Interactive Debugger","text":"<p>If you're running in a terminal or can't use the browser debugger, use <code>print()</code> statements:</p> <pre><code>@app.route(\"/process\")\ndef process_data():\n    data = request.get_json()\n    print(f\"DEBUG: Received data: {data}\")  # Check what you received\n\n    result = data.get(\"value\", 0) * 2\n    print(f\"DEBUG: Calculated result: {result}\")  # Check calculation\n\n    return jsonify({\"result\": result})\n</code></pre> <p>[!TIP] Use descriptive print statements with prefixes like \"DEBUG:\" so you can easily find them in logs and remove them later.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#production-debugging-strategy","title":"Production Debugging Strategy","text":"<p>In production (with <code>debug=False</code>):</p> <ol> <li>Log errors instead of displaying them:</li> </ol> <pre><code>import logging\n\nif __name__ == \"__main__\":\n    if not app.debug:\n        logging.basicConfig(filename='app.log', level=logging.ERROR)\n    app.run()\n</code></pre> <ol> <li>Use proper error handlers (you'll learn this in Level 2B):</li> </ol> <pre><code>@app.errorhandler(500)\ndef handle_500(e):\n    app.logger.error(f\"Server error: {e}\")\n    return jsonify({\"error\": \"Internal server error\"}), 500\n</code></pre>"},{"location":"01_LEVEL_0_BEGINNER.html#quick-reference-debug-mode","title":"Quick Reference: Debug Mode","text":"Feature debug=True debug=False (Production) Auto-reload \u2705 Yes \u274c No Detailed errors \u2705 Show stack trace \u274c Generic error Interactive debugger \u2705 Available \u274c Disabled Security \u26a0\ufe0f Unsafe \u2705 Safe Performance Slower Faster"},{"location":"01_LEVEL_0_BEGINNER.html#try-it-yourself","title":"Try It Yourself","text":"<p>Before moving on to Practice Problems, create an intentional error in your Flask app and:</p> <ol> <li>Visit the error page</li> <li>Click the console icon</li> <li>Inspect at least one variable</li> <li>Fix the error and refresh</li> </ol> <p>This skill will be essential for Test Task 1 and beyond!</p>"},{"location":"01_LEVEL_0_BEGINNER.html#practice-problems","title":"Practice Problems","text":""},{"location":"01_LEVEL_0_BEGINNER.html#problem-1-setup","title":"Problem 1: Setup","text":"<ol> <li>Create a new virtual environment.</li> <li>Install Flask.</li> <li>Freeze requirements to <code>requirements.txt</code>.</li> </ol>"},{"location":"01_LEVEL_0_BEGINNER.html#problem-2-new-endpoint","title":"Problem 2: New Endpoint","text":"<ol> <li>Add a new route <code>/ping</code> to your <code>app.py</code>.</li> <li>It should return <code>{\"pong\": true}</code>.</li> </ol>"},{"location":"01_LEVEL_0_BEGINNER.html#common-pitfalls-quiz","title":"Common Pitfalls Quiz","text":"<p>Test your understanding by identifying what's wrong with these common mistakes juniors make:</p>"},{"location":"01_LEVEL_0_BEGINNER.html#pitfall-1-testing-post-in-browser","title":"Pitfall 1: Testing POST in Browser","text":"<p>Question: Why does this not work?</p> <pre><code>You open Chrome and type: http://127.0.0.1:5000/users\nThe route is defined as: @app.route('/users', methods=['POST'])\nYou get: 405 Method Not Allowed\n</code></pre> Click to see answer  **Answer**: Browsers send **GET** requests when you type a URL in the address bar. This route only accepts POST. You need to use **Postman** or `curl` to send POST requests.  **Fix**: Use Postman or change the methods to `methods=['GET', 'POST']` if you want both."},{"location":"01_LEVEL_0_BEGINNER.html#pitfall-2-forgetting-jsonify","title":"Pitfall 2: Forgetting jsonify()","text":"<p>Question: What's wrong with this code?</p> <pre><code>@app.route('/hello')\ndef hello():\n    return {\"message\": \"Hello\"}  # Returns a Python dict directly\n</code></pre> Click to see answer  **Answer**: While Flask can automatically convert dicts to JSON in newer versions, it's **bad practice** and won't set the proper `Content-Type: application/json` header in older versions.  **Fix**: Always use `jsonify()`:   <pre><code>from flask import jsonify\n\n@app.route('/hello')\ndef hello():\n    return jsonify({\"message\": \"Hello\"})\n</code></pre>"},{"location":"01_LEVEL_0_BEGINNER.html#pitfall-3-debug-mode-in-production","title":"Pitfall 3: Debug Mode in Production","text":"<p>Question: What's wrong with this deployment code?</p> <pre><code># deploy.py\nif __name__== \"__main__\":\n    app.run(host='0.0.0.0', port=80, debug=True)\n</code></pre> Click to see answer  **Answer**: **NEVER use `debug=True` in production!** This:  - Exposes sensitive code and variables via the interactive debugger - Allows attackers to execute Python code on your server - Is a **critical security vulnerability**  **Fix**:   <pre><code># For production, use a WSGI server like Gunicorn:\n# gunicorn -w 4 app:app\n\n# If you must use app.run(), at least set debug=False:\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port=80, debug=False)\n</code></pre>"},{"location":"01_LEVEL_0_BEGINNER.html#pitfall-4-not-activating-virtual-environment","title":"Pitfall 4: Not Activating Virtual Environment","text":"<p>Question: Why doesn't Flask work?</p> <pre><code>$ python app.py\nTraceback (most recent call last):\n  File \"app.py\", line 1, in &lt;module&gt;\n    from flask import Flask\nModuleNotFoundError: No module named 'flask'\n</code></pre> <p>But you installed it with <code>pip install flask</code>...</p> Click to see answer  **Answer**: You forgot to **activate your virtual environment**!  **Fix**:   <pre><code># macOS/Linux\nsource venv/bin/activate\n\n# Windows\nvenv\\Scripts\\activate\n\n# Then run:\npython app.py\n</code></pre>    You'll know it's activated when you see `(venv)` in your terminal prompt."},{"location":"01_LEVEL_0_BEGINNER.html#pitfall-5-wrong-status-code-for-creation","title":"Pitfall 5: Wrong Status Code for Creation","text":"<p>Question: What's wrong with this create endpoint?</p> <pre><code>@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    # ... create user logic ...\n    return jsonify({\"message\": \"User created\"}), 200\n</code></pre> Click to see answer  **Answer**: When creating a resource, you should return **201 Created**, not 200 OK.  **Fix**:   <pre><code>@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    # ... create user logic ...\n    return jsonify({\"message\": \"User created\"}), 201  # 201 Created\n</code></pre>"},{"location":"01_LEVEL_0_BEGINNER.html#trivia","title":"Trivia","text":""},{"location":"01_LEVEL_0_BEGINNER.html#question-1","title":"Question 1","text":"<p>What function do we use to return JSON in Flask?</p> <ul> <li>[ ] <code>json.dumps()</code></li> <li>[x] <code>jsonify()</code></li> <li>[ ] <code>return_json()</code></li> <li>[ ] <code>flask.json()</code></li> </ul> <p>Explanation: <code>jsonify</code> serializes data to JSON and sets the generic Content-Type header to <code>application/json</code>.</p>"},{"location":"01_LEVEL_0_BEGINNER.html#question-2","title":"Question 2","text":"<p>Why do we not use HTML templates in this course?</p> <ul> <li>[ ] HTML is too hard</li> <li>[x] We are building an API that serves data (JSON) to any client (Web, Mobile, etc), decoupling the UI from the Logic.</li> <li>[ ] Flask cannot handle HTML</li> </ul>"},{"location":"01_LEVEL_0_BEGINNER.html#question-3","title":"Question 3","text":"<p>What decorates a function to make it a route?</p> <ul> <li>[ ] <code>@app.endpoint</code></li> <li>[ ] <code>@flask.route</code></li> <li>[x] <code>@app.route</code></li> <li>[ ] <code>@url_path</code></li> </ul>"},{"location":"02_LEVEL_1_FOUNDATIONS.html","title":"Level 1: Flask Foundations - Routing &amp; Requests","text":"<p>Prerequisites: Level 0: Beginner Next Step: Test Task 1</p> <p>[!NOTE] No OOP Required: We still use standard Python functions here. No classes needed!</p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#goal","title":"Goal","text":"<p>In this level, we will learn how to handle different types of requests, work with data sent by clients, and build well-structured APIs.</p> <p>Core Rules for this Level:</p> <ol> <li>API First: We only speak JSON.</li> <li>Thin Routes: Routes should only parse input and return output.</li> <li>No Jinja: We serve static HTML/JS if we need a UI.</li> </ol>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#table-of-contents","title":"Table of Contents","text":"<ol> <li>Routing Basics</li> <li>Handling Requests (The Input)</li> <li>Building Responses (The Output)</li> <li>Serving Static Files</li> <li>Pagination, Filtering, and Versioning</li> <li>Practice Problems</li> </ol>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#routing-basics","title":"Routing Basics","text":""},{"location":"02_LEVEL_1_FOUNDATIONS.html#1-http-api-basics","title":"1. HTTP &amp; API Basics","text":"<p>Before writing code, let's understand the request types and status codes we handle.</p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#http-methods","title":"HTTP Methods","text":"<ul> <li>GET: Retrieve data (Read). Browsers send this by default. Never change data with a GET.</li> <li>POST: Create new data (Create). Used for submitting forms or JSON.</li> <li>PUT: Update an existing resource completely (Replace).</li> <li>PATCH: Update parts of an existing resource (Modify).</li> <li>DELETE: Remove data (Delete).</li> </ul>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#http-status-codes-the-response","title":"HTTP Status Codes (The Response)","text":"<p>Always return the correct status code so the client knows what happened.</p> Code Meaning Usage 200 OK Standard success 201 Created Resource created successfully 400 Bad Request Client sent invalid JSON or missing fields 404 Not Found Resource does not exist 500 Server Error Something broke (Hide details from user!)"},{"location":"02_LEVEL_1_FOUNDATIONS.html#2-how-to-test-the-browser-trap","title":"2. How to Test (The Browser Trap)","text":"<p>[!WARNING] You cannot test POST requests in your browser address bar!</p> <p>When you type a URL in Chrome or Firefox, it always sends a <code>GET</code> request. If you try to visit a <code>POST</code>-only route, you will get a <code>405 Method Not Allowed</code> error.</p> <p>Tools you need:</p> <ol> <li>Postman (Recommended): A GUI app to send any type of HTTP request.</li> <li>cURL: A command-line tool. Example: <code>curl -X POST http://localhost:5000/books</code></li> </ol>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#3-defining-routes","title":"3. Defining Routes","text":"<p>By default, a route only answers to GET. You must explicitly specify other methods.</p> <pre><code>from flask import Flask, jsonify, request\n\napp = Flask(__name__)\n\n@app.route(\"/books\", methods=[\"GET\"])\ndef get_books():\n    return jsonify({\"message\": \"Get all books\"})\n\n@app.route(\"/books\", methods=[\"POST\"])\ndef create_book():\n    return jsonify({\"message\": \"Create a book\"}), 201\n</code></pre> <p>[!TIP] Magic Box \u2013 Flask routing &amp; <code>request</code>: Treat <code>Flask(__name__)</code>, <code>@app.route</code>, <code>jsonify(...)</code>, and the <code>request</code> object as Magic Boxes. You mainly need to know where to read data (<code>request.get_json()</code>, <code>request.args</code>) and what JSON to return.</p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#4-complete-guide-to-http-methods","title":"4. Complete Guide to HTTP Methods","text":"<p>Let's see all the HTTP methods with practical examples. We'll build a simple Book API to demonstrate each method.</p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#get-retrieve-data","title":"GET - Retrieve Data","text":"<p>Use when: You want to read/fetch data without changing anything.</p> <pre><code># Get all books\n@app.route(\"/books\", methods=[\"GET\"])\ndef get_books():\n    books = [\n        {\"id\": 1, \"title\": \"Flask Guide\", \"author\": \"John Doe\"},\n        {\"id\": 2, \"title\": \"Python Basics\", \"author\": \"Jane Smith\"}\n    ]\n    return jsonify({\"books\": books}), 200\n\n# Get a single book by ID\n@app.route(\"/books/&lt;int:book_id&gt;\", methods=[\"GET\"])\ndef get_book(book_id):\n    # In a real app, fetch from database\n    book = {\"id\": book_id, \"title\": \"Flask Guide\", \"author\": \"John Doe\"}\n    return jsonify(book), 200\n</code></pre> <p>Key points:</p> <ul> <li>GET requests never change data</li> <li>Query parameters (<code>?page=1&amp;sort=title</code>) for filtering/pagination</li> <li>Always return 200 OK on success</li> </ul>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#post-create-new-resource","title":"POST - Create New Resource","text":"<p>Use when: You want to create a brand new resource.</p> <pre><code>@app.route(\"/books\", methods=[\"POST\"])\ndef create_book():\n    data = request.get_json()\n\n    # Validation\n    if not data or 'title' not in data or 'author' not in data:\n        return jsonify({\"error\": \"Missing title or author\"}), 400\n\n    # In a real app, save to database and get generated ID\n    new_book = {\n        \"id\": 123,  # Would be auto-generated by DB\n        \"title\": data['title'],\n        \"author\": data['author']\n    }\n\n    return jsonify({\"message\": \"Book created\", \"book\": new_book}), 201\n</code></pre> <p>Key points:</p> <ul> <li>Always return 201 Created on success (not 200)</li> <li>Data comes from request body as JSON</li> <li>Generate/assign ID server-side (never trust client-provided IDs)</li> </ul>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#put-replace-entire-resource","title":"PUT - Replace Entire Resource","text":"<p>Use when: You want to completely replace an existing resource with new data.</p> <pre><code>@app.route(\"/books/&lt;int:book_id&gt;\", methods=[\"PUT\"])\ndef update_book_full(book_id):\n    data = request.get_json()\n\n    # PUT requires ALL fields to be present\n    if not data or 'title' not in data or 'author' not in data:\n        return jsonify({\"error\": \"PUT requires title AND author\"}), 400\n\n    # In a real app, check if book exists first\n    # If not found: return 404\n\n    # Replace the entire resource\n    updated_book = {\n        \"id\": book_id,\n        \"title\": data['title'],\n        \"author\": data['author']\n    }\n\n    return jsonify({\"message\": \"Book replaced\", \"book\": updated_book}), 200\n</code></pre> <p>Key points:</p> <ul> <li>Replaces the entire resource (all fields must be provided)</li> <li>Missing fields would be removed/set to defaults</li> <li>Return 404 if resource doesn't exist</li> <li>Return 200 OK on success</li> </ul> <p>Example:</p> <pre><code>// Before: {\"id\": 1, \"title\": \"Old Title\", \"author\": \"Old Author\", \"year\": 2020}\n// PUT with: {\"title\": \"New Title\", \"author\": \"New Author\"}\n// After: {\"id\": 1, \"title\": \"New Title\", \"author\": \"New Author\"}\n// Notice: 'year' field is gone!\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#patch-partial-update","title":"PATCH - Partial Update","text":"<p>Use when: You want to update only specific fields of a resource.</p> <pre><code>@app.route(\"/books/&lt;int:book_id&gt;\", methods=[\"PATCH\"])\ndef update_book_partial(book_id):\n    data = request.get_json()\n\n    if not data:\n        return jsonify({\"error\": \"No data provided\"}), 400\n\n    # In a real app, fetch existing book from DB\n    existing_book = {\n        \"id\": book_id,\n        \"title\": \"Original Title\",\n        \"author\": \"Original Author\",\n        \"year\": 2020\n    }\n\n    # Check if book exists\n    # if not found: return 404\n\n    # Update only the fields that were sent\n    if 'title' in data:\n        existing_book['title'] = data['title']\n    if 'author' in data:\n        existing_book['author'] = data['author']\n    if 'year' in data:\n        existing_book['year'] = data['year']\n\n    return jsonify({\"message\": \"Book updated\", \"book\": existing_book}), 200\n</code></pre> <p>Key points:</p> <ul> <li>Only updates fields that are provided</li> <li>Other fields remain unchanged</li> <li>More flexible than PUT</li> <li>Most commonly used for updates in modern APIs</li> </ul> <p>Example:</p> <pre><code>// Before: {\"id\": 1, \"title\": \"Old Title\", \"author\": \"Old Author\", \"year\": 2020}\n// PATCH with: {\"title\": \"New Title\"}\n// After: {\"id\": 1, \"title\": \"New Title\", \"author\": \"Old Author\", \"year\": 2020}\n// Notice: 'author' and 'year' are preserved!\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#delete-remove-resource","title":"DELETE - Remove Resource","text":"<p>Use when: You want to permanently remove a resource.</p> <pre><code>@app.route(\"/books/&lt;int:book_id&gt;\", methods=[\"DELETE\"])\ndef delete_book(book_id):\n    # In a real app, check if book exists\n    # If not found: return 404\n\n    # Delete from database\n    # db.session.delete(book)\n    # db.session.commit()\n\n    return jsonify({\"message\": \"Book deleted successfully\"}), 200\n</code></pre> <p>Alternative: You can also return 204 No Content with no response body:</p> <pre><code>@app.route(\"/books/&lt;int:book_id&gt;\", methods=[\"DELETE\"])\ndef delete_book(book_id):\n    # Delete logic here\n    return '', 204  # No content\n</code></pre> <p>Key points:</p> <ul> <li>Return 200 OK with a message, or 204 No Content with empty body</li> <li>Return 404 if resource doesn't exist</li> <li>DELETE is idempotent (calling it multiple times has the same effect)</li> </ul>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#5-quick-reference-when-to-use-which-method","title":"5. Quick Reference: When to Use Which Method","text":"Method Purpose Body Required Idempotent* Success Code GET Retrieve data No Yes 200 POST Create new Yes No 201 PUT Replace entire resource Yes Yes 200 PATCH Update partial Yes No** 200 DELETE Remove No Yes 200 or 204 <p>*Idempotent = calling it multiple times has the same effect as calling it once</p> <p>Common Mistakes to Avoid:</p> <ol> <li>\u274c Using GET to create/update/delete data</li> <li>\u274c Using POST for updates (use PUT or PATCH)</li> <li>\u274c Returning 200 OK when creating resources (use 201 Created)</li> <li>\u274c Using PUT when you only want to update one field (use PATCH)</li> </ol>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#dynamic-urls","title":"Dynamic URLs","text":""},{"location":"02_LEVEL_1_FOUNDATIONS.html#handling-requests-the-input","title":"Handling Requests (The Input)","text":"<p>In an API, we mostly care about JSON Body and Query Parameters.</p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#1-json-body-postput","title":"1. JSON Body (POST/PUT)","text":"<p>Used when creating or updating resources.</p> <pre><code>@app.route(\"/users\", methods=[\"POST\"])\ndef create_user():\n    # request.get_json() parses the JSON body\n    data = request.get_json()\n\n    username = data.get(\"username\")\n    email = data.get(\"email\")\n\n    # In real app: Validate and Save to DB\n\n    return jsonify({\"status\": \"created\", \"username\": username}), 201\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#3-the-request-object-summary","title":"3. The <code>request</code> Object Summary","text":"<p>Confused? Here is a cheat sheet:</p> Data Source Content-Type Usage Flask Accessor JSON <code>application/json</code> Modern APIs (POST/PUT) <code>request.get_json()</code> URL Params N/A Filtering/Sorting (GET) <code>request.args.get('key')</code> Form Data <code>application/x-www-form-urlencoded</code> HTML Forms <code>request.form.get('key')</code> Path Vars N/A Resource IDs Function Argument"},{"location":"02_LEVEL_1_FOUNDATIONS.html#4-query-parameters-get","title":"4. Query Parameters (GET)","text":"<p>Used for filtering or pagination (e.g., <code>/users?page=2&amp;role=admin</code>).</p> <pre><code>@app.route(\"/users\", methods=[\"GET\"])\ndef list_users():\n    # request.args is a dictionary-like object\n    page = request.args.get(\"page\", 1, type=int)\n    role = request.args.get(\"role\")\n\n    return jsonify({\"page\": page, \"filter_role\": role})\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#building-responses-the-output","title":"Building Responses (The Output)","text":"<p>Always return <code>jsonify</code> and a proper Status Code (see the table in HTTP &amp; API Basics).</p> <pre><code>@app.route(\"/orders\", methods=[\"POST\"])\ndef create_order():\n    data = request.get_json()\n\n    if not data or \"item\" not in data:\n        # 400 Bad Request\n        return jsonify({\"error\": \"Missing 'item' field\"}), 400\n\n    return jsonify({\"id\": 123, \"status\": \"pending\"}), 201\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#error-handling-and-status-codes","title":"Error Handling and Status Codes","text":"<p>Proper error handling is critical for building production-ready APIs. This section prepares you for Test Task 1 and real-world development.</p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#understanding-http-status-codes-detailed","title":"Understanding HTTP Status Codes (Detailed)","text":"<p>We saw a brief table earlier. Now let's understand each error code with practical examples.</p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#200-ok-success","title":"200 OK - Success","text":"<p>Use when: The request succeeded and you're returning data.</p> <pre><code>@app.route(\"/users/&lt;int:user_id&gt;\", methods=[\"GET\"])\ndef get_user(user_id):\n    user = {\"id\": user_id, \"name\": \"Alice\"}\n    return jsonify(user), 200\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#201-created-resource-created","title":"201 Created - Resource Created","text":"<p>Use when: A new resource was successfully created.</p> <pre><code>@app.route(\"/users\", methods=[\"POST\"])\ndef create_user():\n    data = request.get_json()\n    # Create logic here\n    return jsonify({\"id\": 123, \"name\": data['name']}), 201\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#400-bad-request-client-error","title":"400 Bad Request - Client Error","text":"<p>Use when: The client sent invalid/malformed data or missing required fields.</p> <p>Common scenarios:</p> <ul> <li>Missing required fields</li> <li>Invalid JSON format</li> <li>Invalid data types</li> <li>Validation failures</li> <li>Invalid UUID/ID format</li> </ul> <pre><code>@app.route(\"/users\", methods=[\"POST\"])\ndef create_user():\n    data = request.get_json()\n\n    # Scenario 1: No JSON body\n    if not data:\n        return jsonify({\"error\": \"Request body is required\"}), 400\n\n    # Scenario 2: Missing required fields\n    if 'name' not in data:\n        return jsonify({\"error\": \"Missing 'name' field\"}), 400\n\n    if 'email' not in data:\n        return jsonify({\"error\": \"Missing 'email' field\"}), 400\n\n    # Scenario 3: Invalid data type\n    if not isinstance(data.get('age'), int):\n        return jsonify({\"error\": \"Age must be an integer\"}), 400\n\n    # Success\n    return jsonify({\"message\": \"User created\"}), 201\n</code></pre> <p>Example: Invalid UUID Format</p> <pre><code>import uuid\n\n@app.route(\"/users/&lt;user_id&gt;\", methods=[\"GET\"])\ndef get_user(user_id):\n    # Validate UUID format\n    try:\n        uuid.UUID(user_id)\n    except ValueError:\n        return jsonify({\"error\": \"Invalid UUID format\"}), 400\n\n    # Proceed with valid UUID\n    user = {\"id\": user_id, \"name\": \"Alice\"}\n    return jsonify(user), 200\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#404-not-found-resource-doesnt-exist","title":"404 Not Found - Resource Doesn't Exist","text":"<p>Use when: The requested resource (user, product, etc.) cannot be found.</p> <pre><code># Mock database\nusers = [\n    {\"id\": \"a1b2c3\", \"name\": \"Alice\"},\n    {\"id\": \"d4e5f6\", \"name\": \"Bob\"}\n]\n\n@app.route(\"/users/&lt;user_id&gt;\", methods=[\"GET\"])\ndef get_user(user_id):\n    # Search for user\n    user = next((u for u in users if u['id'] == user_id), None)\n\n    if not user:\n        return jsonify({\"error\": \"User not found\"}), 404\n\n    return jsonify(user), 200\n</code></pre> <p>DELETE example:</p> <pre><code>@app.route(\"/users/&lt;user_id&gt;\", methods=[\"DELETE\"])\ndef delete_user(user_id):\n    user = next((u for u in users if u['id'] == user_id), None)\n\n    if not user:\n        return jsonify({\"error\": \"User not found\"}), 404\n\n    users.remove(user)\n    return jsonify({\"message\": \"User deleted successfully\"}), 200\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#500-internal-server-error-something-went-wrong","title":"500 Internal Server Error - Something Went Wrong","text":"<p>Use when: An unexpected error occurs on the server (database crash, file system error, etc.).</p> <p>[!IMPORTANT] Never expose internal error details to clients! This is a security risk. Log the full error server-side, but return a generic message to the client.</p> <pre><code>@app.route(\"/users\", methods=[\"GET\"])\ndef get_users():\n    try:\n        # Simulating file read that might fail\n        with open(\"users.json\", \"r\") as f:\n            users = json.load(f)\n        return jsonify({\"users\": users}), 200\n\n    except FileNotFoundError:\n        # Log the error internally\n        print(\"ERROR: users.json not found!\")\n\n        # Return generic error to client\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n    except json.JSONDecodeError:\n        print(\"ERROR: Invalid JSON in users.json\")\n        return jsonify({\"error\": \"Internal server error\"}), 500\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#handling-invalid-json","title":"Handling Invalid JSON","text":"<p>When <code>request.get_json()</code> fails because the client sent malformed JSON:</p> <pre><code>@app.route(\"/users\", methods=[\"POST\"])\ndef create_user():\n    try:\n        data = request.get_json()\n    except Exception:\n        return jsonify({\"error\": \"Invalid JSON\"}), 400\n\n    if not data:\n        return jsonify({\"error\": \"Request body is required\"}), 400\n\n    # Process valid JSON\n    return jsonify({\"message\": \"User created\"}), 201\n</code></pre> <p>Better approach using Flask's built-in handling:</p> <pre><code>@app.route(\"/users\", methods=[\"POST\"])\ndef create_user():\n    # Flask automatically returns 400 for malformed JSON if force=False (default)\n    data = request.get_json()\n\n    if data is None:\n        return jsonify({\"error\": \"Invalid or missing JSON\"}), 400\n\n    # Proceed with valid data\n    return jsonify({\"message\": \"User created\"}), 201\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#complete-error-handling-example","title":"Complete Error Handling Example","text":"<p>Here's a complete example showing all the error handling patterns you've learned, using a product inventory system:</p> <pre><code>from flask import Flask, jsonify, request\nimport json\n\napp = Flask(__name__)\n\n@app.route(\"/products/&lt;int:product_id&gt;\", methods=[\"GET\"])\ndef get_product(product_id):\n    # Error 1: Validate product_id is positive\n    if product_id &lt;= 0:\n        return jsonify({\"error\": \"Invalid product ID\"}), 400\n\n    # Error 2: Load products from file\n    try:\n        with open(\"inventory.json\", \"r\") as f:\n            data = json.load(f)\n            products = data.get(\"products\", [])\n    except FileNotFoundError:\n        return jsonify({\"error\": \"Internal server error\"}), 500\n    except json.JSONDecodeError:\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n    # Error 3: Product not found\n    product = next((p for p in products if p['id'] == product_id), None)\n    if not product:\n        return jsonify({\"error\": \"Product not found\"}), 404\n\n    # Success\n    return jsonify(product), 200\n\n\n@app.route(\"/products\", methods=[\"POST\"])\ndef create_product():\n    data = request.get_json()\n\n    # Error 1: No data\n    if not data:\n        return jsonify({\"error\": \"Request body required\"}), 400\n\n    # Error 2: Missing required fields\n    if 'name' not in data or 'price' not in data:\n        return jsonify({\"error\": \"Missing name or price\"}), 400\n\n    # Error 3: Invalid data type\n    if not isinstance(data['price'], (int, float)) or data['price'] &lt; 0:\n        return jsonify({\"error\": \"Price must be a positive number\"}), 400\n\n    # Success - create product\n    new_product = {\n        \"id\": 123,  # Would be generated\n        \"name\": data['name'],\n        \"price\": data['price']\n    }\n    return jsonify(new_product), 201\n</code></pre> <p>This example demonstrates:</p> <ul> <li>Validation errors (400)</li> <li>File operation errors (500)</li> <li>Resource not found errors (404)</li> <li>Proper try-except blocks</li> <li>Clean error messages</li> </ul> <p>You can apply these same patterns to any API you build, including Test Task 1!</p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#using-try-except-blocks-effectively","title":"Using Try-Except Blocks Effectively","text":"<p>Pattern for file operations:</p> <pre><code>try:\n    with open(\"data.json\", \"r\") as f:\n        data = json.load(f)\nexcept FileNotFoundError:\n    # File doesn't exist - maybe first run\n    data = {\"users\": []}\nexcept json.JSONDecodeError:\n    # File is corrupted\n    return jsonify({\"error\": \"Internal server error\"}), 500\nexcept Exception as e:\n    # Unexpected error\n    print(f\"Unexpected error: {e}\")\n    return jsonify({\"error\": \"Internal server error\"}), 500\n</code></pre> <p>Pattern for validation:</p> <pre><code>def validate_user_data(data):\n    \"\"\"Helper function to validate user data. Returns error message or None.\"\"\"\n    if not data:\n        return \"Request body is required\"\n\n    if 'name' not in data:\n        return \"Missing 'name' field\"\n\n    if 'email' not in data:\n        return \"Missing 'email' field\"\n\n    if 'age' in data and not isinstance(data['age'], int):\n        return \"Age must be an integer\"\n\n    return None  # No errors\n\n@app.route(\"/users\", methods=[\"POST\"])\ndef create_user():\n    data = request.get_json()\n\n    error = validate_user_data(data)\n    if error:\n        return jsonify({\"error\": error}), 400\n\n    # Proceed with valid data\n    return jsonify({\"message\": \"User created\"}), 201\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#quick-reference-error-handling-checklist","title":"Quick Reference: Error Handling Checklist","text":"<p>Before submitting Test Task 1, ensure you handle:</p> <ul> <li>[ ] 400: Missing request body</li> <li>[ ] 400: Missing required fields</li> <li>[ ] 400: Invalid JSON format</li> <li>[ ] 400: Invalid UUID format (for URL parameters)</li> <li>[ ] 404: User/resource not found</li> <li>[ ] 500: File read/write errors</li> <li>[ ] 500: Unexpected exceptions</li> </ul>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":"<ol> <li>\u274c Exposing internal errors</li> </ol> <p><code>python    # BAD - Don't do this!    return jsonify({\"error\": str(exception)}), 500</code></p> <ol> <li>\u274c Not validating required fields</li> </ol> <p><code>python    # BAD - Will crash if 'name' is missing    name = data['name']</code></p> <ol> <li>\u274c Using wrong status codes</li> </ol> <p><code>python    # BAD - Resource created should be 201, not 200    return jsonify({\"message\": \"Created\"}), 200</code></p> <ol> <li>\u274c Not handling file operations safely</li> </ol> <p><code>python    # BAD - What if file doesn't exist?    data = json.load(open(\"users.json\"))</code></p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#serving-static-files","title":"Serving Static Files","text":"<p>Since we do not use Jinja templates, we handle UI by serving static HTML/JS files that consume our JSON API.</p> <p>Place files in a <code>static</code> folder:</p> <pre><code>project/\n\u251c\u2500\u2500 static/\n\u2502   \u251c\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 app.js\n\u2514\u2500\u2500 app.py\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#serving-the-entry-point","title":"Serving the Entry Point","text":"<pre><code>@app.route(\"/\")\ndef index():\n    # Send the static index.html file\n    return app.send_static_file(\"index.html\")\n</code></pre> <p>Your <code>index.html</code> should use JavaScript (<code>fetch</code> or <code>axios</code>) to call your API endpoints (e.g., <code>/users</code>) and display data.</p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#pagination-filtering-and-versioning","title":"Pagination, Filtering, and Versioning","text":"<p>At some point your API will outgrow simple \u201creturn all rows\u201d endpoints. You need a consistent way to page, filter, and version your APIs.</p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#1-basic-pagination-pattern","title":"1. Basic pagination pattern","text":"<p>Use <code>page</code> and <code>page_size</code> (or <code>limit</code> and <code>offset</code>) as query parameters:</p> <pre><code>@app.route(\"/items\", methods=[\"GET\"])\ndef list_items():\n    page = request.args.get(\"page\", 1, type=int)\n    page_size = request.args.get(\"page_size\", 20, type=int)\n\n    # pretend this comes from your DB\n    items = [\n        {\"id\": 1, \"name\": \"Item 1\"},\n        {\"id\": 2, \"name\": \"Item 2\"},\n    ]\n\n    return jsonify({\n        \"items\": items,\n        \"page\": page,\n        \"page_size\": page_size,\n        \"total\": len(items),\n    })\n</code></pre> <p>Recommended response envelope:</p> <ul> <li><code>items</code>: list of resources</li> <li><code>page</code>: current page</li> <li><code>page_size</code>: how many per page</li> <li><code>total</code>: total number of items</li> </ul>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#2-filtering-and-searching","title":"2. Filtering and searching","text":"<p>Reuse query params for filters instead of inventing custom URLs:</p> <ul> <li><code>/users?role=admin</code></li> <li><code>/books?author_id=1&amp;price_min=10&amp;price_max=50</code></li> </ul> <p>Example:</p> <pre><code>@app.route(\"/books\", methods=[\"GET\"])\ndef list_books():\n    author_id = request.args.get(\"author_id\", type=int)\n    price_min = request.args.get(\"price_min\", type=float)\n    price_max = request.args.get(\"price_max\", type=float)\n\n    return jsonify({\n        \"author_id\": author_id,\n        \"price_min\": price_min,\n        \"price_max\": price_max,\n    })\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#3-api-versioning","title":"3. API versioning","text":"<p>When you need to introduce breaking changes, do not silently change existing URLs. Add a version prefix:</p> <ul> <li><code>/api/v1/books</code></li> <li><code>/api/v2/books</code></li> </ul> <p>Later levels and Test Task 3 use prefixes like <code>/api/v1/authors</code> and <code>/api/v1/books</code>. You should follow the same idea in your own projects.</p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#practice-problems","title":"Practice Problems","text":""},{"location":"02_LEVEL_1_FOUNDATIONS.html#problem-1-calculator-api","title":"Problem 1: Calculator API","text":"<p>Create an endpoint <code>/calculate</code> that accepts a POST request with JSON: <code>{\"operation\": \"add\", \"x\": 10, \"y\": 5}</code> And returns: <code>{\"result\": 15}</code>. Support add, subtract, multiply, divide. Return 400 for invalid operations.</p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#problem-2-calculator-api-extended","title":"Problem 2: Calculator API (Extended)","text":"<p>Build on the calculator from earlier. Create a <code>/calculate</code> endpoint that:</p> <ol> <li>Takes JSON: <code>{\"operation\": \"add\", \"x\": 10, \"y\": 5}</code></li> <li>Returns: <code>{\"result\": 15}</code></li> <li>Supports: <code>add</code>, <code>subtract</code>, <code>multiply</code>, <code>divide</code></li> <li>Returns 400 for invalid operations</li> </ol> <p>Starter code:</p> <pre><code>from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/calculate', methods=['POST'])\ndef calculate():\n    data = request.get_json()\n\n    if not data or 'operation' not in data:\n        return jsonify({\"error\": \"Missing operation\"}), 400\n\n    operation = data['operation']\n    x = data.get('x', 0)\n    y = data.get('y', 0)\n\n    if operation == 'add':\n        result = x + y\n    elif operation == 'subtract':\n        result = x - y\n    elif operation == 'multiply':\n        result = x * y\n    elif operation == 'divide':\n        if y == 0:\n            return jsonify({\"error\": \"Cannot divide by zero\"}), 400\n        result = x / y\n    else:\n        return jsonify({\"error\": \"Invalid operation\"}), 400\n\n    return jsonify({\"result\": result}), 200\n\nif __name__ == '__main__':\n    app.run(debug=True)\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#problem-3-query-params","title":"Problem 3: Query Params","text":"<p>Create a route <code>/search</code> that takes a query param <code>q</code>. If <code>q</code> is missing, return error 400. If present, return <code>{\"query\": q}</code>.</p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#common-pitfalls-quiz","title":"Common Pitfalls Quiz","text":"<p>Test your understanding of common mistakes juniors make with Flask routing and request handling:</p>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#pitfall-1-using-wrong-http-method","title":"Pitfall 1: Using Wrong HTTP Method","text":"<p>Question: Why does this update endpoint fail when called correctly?</p> <pre><code>@app.route('/users/&lt;int:id&gt;', methods=['GET'])\ndef update_user(id):\n    data = request.get_json()\n    # Update logic here\n    return jsonify({\"message\": \"Updated\"}), 200\n</code></pre> <p>Client sends: <code>PATCH /users/1</code> with JSON body</p> Click to see answer  **Answer**: The route only accepts **GET** requests, but updating data should use **PATCH** or **PUT**.  **Fix**:   <pre><code>@app.route('/users/&lt;int:id&gt;', methods=['PATCH'])  # Or ['PUT']\ndef update_user(id):\n    data = request.get_json()\n    # Update logic here\n    return jsonify({\"message\": \"Updated\"}), 200\n</code></pre>    **Remember**:  * GET = Read * POST = Create * PUT/PATCH = Update * DELETE = Delete"},{"location":"02_LEVEL_1_FOUNDATIONS.html#pitfall-2-not-validating-request-data","title":"Pitfall 2: Not Validating Request Data","text":"<p>Question: What's wrong with this code?</p> <pre><code>@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    name = data['name']  # What if 'name' doesn't exist?\n    email = data['email']  # What if data is None?\n    # ... create user ...\n    return jsonify({\"message\": \"Created\"}), 201\n</code></pre> Click to see answer  **Answer**: No validation! This will crash if:  1. Client doesn't send JSON (data is None) 2. Client sends JSON but missing 'name' or 'email' fields  **Fix**:   <pre><code>@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n\n    # Validate data exists\n    if not data:\n        return jsonify({\"error\": \"Request body required\"}), 400\n\n    # Validate required fields\n    if 'name' not in data:\n        return jsonify({\"error\": \"Missing 'name' field\"}), 400\n\n    if 'email' not in data:\n        return jsonify({\"error\": \"Missing 'email' field\"}), 400\n\n    # Now safe to access\n    name = data['name']\n    email = data['email']\n    # ... create user ...\n    return jsonify({\"message\": \"Created\"}), 201\n</code></pre>    **Better approach using .get()**:   <pre><code>name = data.get('name')\nif not name:\n    return jsonify({\"error\": \"Missing 'name' field\"}), 400\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#pitfall-3-not-handling-file-errors","title":"Pitfall 3: Not Handling File Errors","text":"<p>Question: What happens if <code>users.json</code> doesn't exist?</p> <pre><code>@app.route('/users', methods=['GET'])\ndef get_users():\n    with open('users.json', 'r') as f:\n        data = json.load(f)\n    return jsonify(data), 200\n</code></pre> Click to see answer  **Answer**: `FileNotFoundError` crash! User sees HTML error page instead of JSON.  **Fix**:   <pre><code>import json\n\n@app.route('/users', methods=['GET'])\ndef get_users():\n    try:\n        with open('users.json', 'r') as f:\n            data = json.load(f)\n        return jsonify(data), 200\n    except FileNotFoundError:\n        # File doesn't exist yet, return empty list\n        return jsonify({\"users\": []}), 200\n    except json.JSONDecodeError:\n        # File is corrupted\n        return jsonify({\"error\": \"Internal server error\"}), 500\n</code></pre>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#pitfall-4-forgetting-to-validate-uuid-format","title":"Pitfall 4: Forgetting to Validate UUID Format","text":"<p>Question: What happens when a user visits <code>/users/invalid-id</code>?</p> <pre><code>import uuid\n\n@app.route('/users/&lt;user_id&gt;', methods=['GET'])\ndef get_user(user_id):\n    users = load_users()  # Load from file\n    user = next((u for u in users if u['id'] == user_id), None)\n\n    if not user:\n        return jsonify({\"error\": \"User not found\"}), 404\n\n    return jsonify(user), 200\n</code></pre> Click to see answer  **Answer**: It returns 404 even for invalid UUIDs, which is misleading. The client should get 400 (Bad Request) for invalid format.  **Fix**:   <pre><code>import uuid\n\n@app.route('/users/&lt;user_id&gt;', methods=['GET'])\ndef get_user(user_id):\n    # Validate UUID format first\n    try:\n        uuid.UUID(user_id)\n    except ValueError:\n        return jsonify({\"error\": \"Invalid UUID format\"}), 400\n\n    users = load_users()\n    user = next((u for u in users if u['id'] == user_id), None)\n\n    if not user:\n        return jsonify({\"error\": \"User not found\"}), 404\n\n    return jsonify(user), 200\n</code></pre>    **Why this matters**: Proper error codes help clients debug:  * 400 = Client sent bad data (invalid UUID) * 404 = valid UUID but user doesn't exist"},{"location":"02_LEVEL_1_FOUNDATIONS.html#pitfall-5-using-get-with-requestget_json","title":"Pitfall 5: Using  GET with request.get_json()","text":"<p>Question: Why is data always None?</p> <p>in```python @app.route('/search', methods=['GET']) def search():     data = request.get_json()     query = data.get('query')  # None!     return jsonify({\"query\": query})</p> <pre><code>&lt;details&gt;\n&lt;summary&gt;Click to see answer&lt;/summary&gt;\n\n**Answer**: **GET requests don't have request bodies!** Use query parameters instead.\n\n**Fix**:\n\n```python\n@app.route('/search', methods=['GET'])\ndef search():\n    # Use request.args for query parameters\n    query = request.args.get('query')\n\n    if not query:\n        return jsonify({\"error\": \"Missing 'query' parameter\"}), 400\n\n    return jsonify({\"query\": query})\n</code></pre> <p>Call like: <code>GET /search?query=flask</code></p> <p>Remember:</p> <ul> <li>GET = Use <code>request.args</code> (query params)</li> <li>POST/PUT/PATCH = Use <code>request.get_json()</code> (body)</li> </ul>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#trivia","title":"Trivia","text":""},{"location":"02_LEVEL_1_FOUNDATIONS.html#question-1","title":"Question 1","text":"<p>How do you access the JSON body sent by a client?</p> <ul> <li>[ ] <code>request.body</code></li> <li>[x] <code>request.get_json()</code></li> <li>[ ] <code>request.json_data</code></li> <li>[ ] <code>json.load(request)</code></li> </ul>"},{"location":"02_LEVEL_1_FOUNDATIONS.html#question-3","title":"Question 3","text":"<p>If a client sends invalid data, what status code should you return?</p> <ul> <li>[ ] 200 OK</li> <li>[ ] 500 Server Error</li> <li>[x] 400 Bad Request</li> <li>[ ] 404 Not Found</li> </ul>"},{"location":"03_TEST_TASK_1.html","title":"Flask Test Task 1 \u2013 JSON File-Based CRUD API","text":"<p>STOP: Do not attempt this task until you have completed Level 1: Foundations. Next Level: Level 2A: Databases</p>"},{"location":"03_TEST_TASK_1.html#objective","title":"Objective","text":"<p>Build a Flask-based REST API that performs Create, Read, Update, and Delete (CRUD) operations on a JSON file acting as a simple database.</p> <p>This task evaluates:</p> <ul> <li>Flask fundamentals</li> <li>REST API design</li> <li>File handling</li> <li>Error handling</li> <li>Code structure and clarity</li> </ul>"},{"location":"03_TEST_TASK_1.html#problem-statement","title":"Problem Statement","text":"<p>You are required to create a Flask application that manages a collection of users stored in a JSON file. The application should expose REST APIs that allow clients to:</p> <ul> <li>Create a new user</li> <li>Retrieve users</li> <li>Update an existing user</li> <li>Delete a user</li> </ul>"},{"location":"03_TEST_TASK_1.html#data-format","title":"Data Format","text":"<p>Store data in a file called <code>users.json</code>.</p>"},{"location":"03_TEST_TASK_1.html#initial-structure","title":"Initial Structure","text":"<pre><code>{\n  \"users\": []\n}\n</code></pre>"},{"location":"03_TEST_TASK_1.html#user-object-structure","title":"User Object Structure","text":"<pre><code>{\n  \"id\": \"a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d\",\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"age\": 30\n}\n</code></pre>"},{"location":"03_TEST_TASK_1.html#api-requirements","title":"API Requirements","text":""},{"location":"03_TEST_TASK_1.html#1-create-user","title":"1. Create User","text":"<p>POST <code>/users</code></p> <p>Request Body:</p> <pre><code>{\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\",\n  \"age\": 25\n}\n</code></pre> <p>Behavior:</p> <ul> <li>Automatically generate a unique UUID as the id</li> <li>Save the user to users.json</li> </ul> <p>Response (201 Created):</p> <pre><code>{\n  \"message\": \"User created successfully\",\n  \"user\": {\n    \"id\": \"a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d\",\n    \"name\": \"Alice\",\n    \"email\": \"alice@example.com\",\n    \"age\": 25\n  }\n}\n</code></pre>"},{"location":"03_TEST_TASK_1.html#2-get-all-users","title":"2. Get All Users","text":"<p>GET <code>/users</code></p> <p>Response:</p> <pre><code>{\n  \"users\": [\n    {\n      \"id\": \"a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d\",\n      \"name\": \"Alice\",\n      \"email\": \"alice@example.com\",\n      \"age\": 25\n    }\n  ]\n}\n</code></pre>"},{"location":"03_TEST_TASK_1.html#3-get-single-user","title":"3. Get Single User","text":"<p>GET <code>/users/&lt;uuid&gt;</code></p> <p>Response (200 OK):</p> <pre><code>{\n  \"id\": \"a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d\",\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\",\n  \"age\": 25\n}\n</code></pre> <p>Error (404):</p> <pre><code>{\n  \"error\": \"User not found\"\n}\n</code></pre> <p>Error (400 - Invalid UUID format):</p> <pre><code>{\n  \"error\": \"Invalid UUID format\"\n}\n</code></pre>"},{"location":"03_TEST_TASK_1.html#4-update-user","title":"4. Update User","text":"<p>PATCH <code>/users/&lt;uuid&gt;</code></p> <p>Request Body:</p> <pre><code>{\n  \"name\": \"Alice Smith\",\n  \"age\": 26\n}\n</code></pre> <p>Behavior:</p> <ul> <li>Update only the provided fields</li> <li>Keep other fields unchanged</li> </ul> <p>Response:</p> <pre><code>{\n  \"message\": \"User updated successfully\",\n  \"user\": {\n    \"id\": \"a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d\",\n    \"name\": \"Alice Smith\",\n    \"email\": \"alice@example.com\",\n    \"age\": 26\n  }\n}\n</code></pre>"},{"location":"03_TEST_TASK_1.html#5-delete-user","title":"5. Delete User","text":"<p>DELETE <code>/users/&lt;uuid&gt;</code></p> <p>Response:</p> <pre><code>{\n  \"message\": \"User deleted successfully\"\n}\n</code></pre>"},{"location":"03_TEST_TASK_1.html#validation-error-handling","title":"Validation &amp; Error Handling","text":"<p>The application should handle:</p> <ul> <li>Missing request body fields</li> <li>Invalid JSON</li> <li>Non-existent user UUIDs</li> <li>Invalid UUID format in URL</li> <li>Empty JSON file</li> <li>Concurrent file access safety (basic handling)</li> </ul> <p>Use proper HTTP status codes:</p> <ul> <li>200 OK</li> <li>201 Created</li> <li>400 Bad Request</li> <li>404 Not Found</li> <li>500 Internal Server Error</li> </ul>"},{"location":"03_TEST_TASK_1.html#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Use Python's built-in <code>uuid</code> module to generate UUIDs (e.g., <code>uuid.uuid4()</code>)</li> <li>Convert UUIDs to strings when storing in JSON</li> <li>Validate UUID format before performing operations (consider using <code>uuid.UUID()</code> for validation)</li> </ul>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html","title":"Level 2A: Intermediate - Databases &amp; The Service Layer","text":"<p>Prerequisites: Test Task 1 Next Level: Level 2B: Serialization</p> <p>[!NOTE] OOP Level: Low. We define classes for database models and services, but they are mostly configuration and namespaces for functions. You do not need to understand constructors, inheritance, or polymorphism to follow this level.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#goal","title":"Goal","text":"<p>In this level, we connect our Flask application to a Relational Database using Flask-SQLAlchemy. Crucially, we will learn the Service Layer Pattern to keep our code clean, scalable, and professional.</p> <p>Strict Rules:</p> <ol> <li>Thin Routes: Routes never access the database directly.</li> <li>Service Layer: All business logic and DB calls reside in services.</li> <li>ORM Only: Use SQLAlchemy models, not raw SQL.</li> </ol>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#table-of-contents","title":"Table of Contents","text":"<ol> <li>Setting Up Flask-SQLAlchemy</li> <li>Defining Models</li> <li>Database Migrations</li> <li>The Service Layer Pattern</li> <li>Refactoring: The Right Way</li> <li>Practice Problems</li> </ol>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#setting-up-flask-sqlalchemy","title":"Setting Up Flask-SQLAlchemy","text":"<p>Install dependencies:</p> <pre><code>pip install flask-sqlalchemy flask-migrate psycopg2-binary\n</code></pre> <p>[!NOTE] We use psycopg2 for PostgreSQL, but strict ORM usage means we can switch easily.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#configuration","title":"Configuration","text":""},{"location":"04_LEVEL_2A_INTERMEDIATE.html#why-extensionspy","title":"Why <code>extensions.py</code>?","text":"<p>In larger Flask applications, we create a separate <code>extensions.py</code> file to avoid circular import problems.</p> <p>The Problem:</p> <ul> <li><code>app.py</code> needs to import models to register routes</li> <li><code>models.py</code> needs <code>db</code> to define tables</li> <li>If both files import from each other \u2192 CircularImportError</li> </ul> <p>The Solution:</p> <ul> <li>Create <code>extensions.py</code> to hold <code>db</code> and <code>migrate</code></li> <li>Both <code>app.py</code> and <code>models.py</code> import from <code>extensions.py</code></li> <li>No circular dependency!</li> </ul> <p>[!NOTE] For tiny projects, you could put everything in <code>app.py</code>. But learning the <code>extensions.py</code> pattern now will save you pain later.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#file-structure","title":"File Structure","text":"<p>Here's how to organize your Flask project:</p> <pre><code>my_flask_project/\n\u251c\u2500\u2500 app.py              # Application factory and routes\n\u251c\u2500\u2500 extensions.py       # Database and migration objects\n\u251c\u2500\u2500 models.py           # Database models\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 migrations/         # Created after 'flask db init'\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#step-1-create-extensionspy","title":"Step 1: Create <code>extensions.py</code>","text":"<pre><code># extensions.py\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_migrate import Migrate\n\ndb = SQLAlchemy()\nmigrate = Migrate()\n</code></pre> <p>This file just creates the \"magic boxes\" - they're not connected to any app yet.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#step-2-create-your-app-in-apppy","title":"Step 2: Create Your App in <code>app.py</code>","text":"<pre><code># app.py\nfrom flask import Flask\nfrom extensions import db, migrate\n\ndef create_app():\n    app = Flask(__name__)\n\n    # Configure your DB URI\n    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'  # or postgresql://...\n    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  # Recommended\n\n    # Initialize extensions with app\n    db.init_app(app)\n    migrate.init_app(app, db)\n\n    return app\n\nif __name__ == \"__main__\":\n    app = create_app()\n    app.run(debug=True)\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#step-3-define-models-in-modelspy","title":"Step 3: Define Models in <code>models.py</code>","text":"<pre><code># models.py\nfrom extensions import db  # Import db from extensions, not app!\n\nclass User(db.Model):\n    __tablename__ = 'users'\n\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#step-4-critical-import-models-in-apppy","title":"Step 4: CRITICAL - Import Models in <code>app.py</code>","text":"<p>[!WARNING] Flask-Migrate will NOT detect your models unless you import them!</p> <p>Update your <code>app.py</code>:</p> <pre><code># app.py\nfrom flask import Flask\nfrom extensions import db, migrate\nfrom models import User  # Import models so migrations detect them\n\ndef create_app():\n    app = Flask(__name__)\n    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'\n\n    db.init_app(app)\n    migrate.init_app(app, db)\n\n    return app\n</code></pre> <p>Why import inside the function? To avoid circular imports. By importing inside <code>create_app()</code>, both files can safely import from <code>extensions.py</code> first.</p> <p>[!TIP] Magic Box \u2013 <code>db</code> and <code>migrate</code>: <code>db = SQLAlchemy()</code> and <code>migrate = Migrate()</code> create Magic Boxes that handle the low-level database work and migrations for you. You mainly need to import them from <code>extensions.py</code> and run <code>flask db migrate</code> / <code>flask db upgrade</code> when models change.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#defining-models","title":"Defining Models","text":"<p>Models are Python classes that map to database tables.</p> <pre><code># models.py\nfrom extensions import db\n\nclass User(db.Model):\n    __tablename__ = 'users'\n\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password_hash = db.Column(db.String(255), nullable=False)\n    is_active = db.Column(db.Boolean, default=True)\n\n    def __repr__(self):\n        return f'&lt;User {self.username}&gt;'\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#model-relationships","title":"Model Relationships","text":"<p>When your data is related (like Authors and their Books), you need to define relationships.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#one-to-many-relationship","title":"One-to-Many Relationship","text":"<p>Example: One Author can have multiple Books. One Book belongs to one Author.</p> <pre><code># models.py\nfrom extensions import db\n\nclass Author(db.Model):\n    __tablename__ = 'authors'\n\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(100), unique=True, nullable=False)\n    bio = db.Column(db.String(500))\n\n    # One-to-Many: One author has many books\n    books = db.relationship('Book', backref='author', cascade='all, delete-orphan')\n\nclass Book(db.Model):\n    __tablename__ = 'books'\n\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(200), nullable=False)\n    price = db.Column(db.Float, nullable=False)\n\n    # Foreign Key: Links to Author table\n    author_id = db.Column(db.Integer, db.ForeignKey('authors.id'), nullable=False)\n</code></pre> <p>Key parts explained:</p> <ol> <li><code>db.ForeignKey('authors.id')</code>: Creates a link to the <code>authors</code> table's <code>id</code> column</li> <li><code>db.relationship('Book', ...)</code>: Tells SQLAlchemy how models are connected</li> <li><code>backref='author'</code>: Automatically creates <code>book.author</code> to access the author from a book</li> <li><code>cascade='all, delete-orphan'</code>: When you delete an author, all their books are deleted too</li> </ol> <p>Using relationships in code:</p> <pre><code># Create an author\nauthor = Author(name=\"J.K. Rowling\", bio=\"British author\")\ndb.session.add(author)\ndb.session.commit()\n\n# Create books for that author\nbook1 = Book(title=\"Harry Potter\", price=19.99, author_id=author.id)\nbook2 = Book(title=\"Fantastic Beasts\", price=15.99, author_id=author.id)\ndb.session.add_all([book1, book2])\ndb.session.commit()\n\n# Access author's books\nprint(author.books)  # [&lt;Book Harry Potter&gt;, &lt;Book Fantastic Beasts&gt;]\n\n# Access book's author (thanks to backref)\nprint(book1.author)  # &lt;Author J.K. Rowling&gt;\n\n# Cascade delete: Delete author deletes all their books\ndb.session.delete(author)\ndb.session.commit()\n# Both books are automatically deleted!\n</code></pre> <p>Common cascade options:</p> <ul> <li><code>'all, delete-orphan'</code>: Delete children when parent is deleted (most common)</li> <li><code>'all'</code>: All operations cascade, but orphans remain</li> <li><code>None</code>: No cascading (default)</li> </ul> <p>[!NOTE] For Test Task 2: You'll need to use exactly this pattern for Authors and Books with cascade delete!</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#database-migrations","title":"Database Migrations","text":""},{"location":"04_LEVEL_2A_INTERMEDIATE.html#why-migrations","title":"Why Migrations?","text":"<p>Imagine you have a running website with 10,000 users in your database. You realize you need to add a <code>phone_number</code> column to the <code>users</code> table.</p> <p>Bad approach (loses all data):</p> <pre><code># Delete the database and recreate it\nos.remove('app.db')\ndb.create_all()  # All 10,000 users are gone!\n</code></pre> <p>Good approach (with migrations):</p> <pre><code># Add column to model, then run:\nflask db migrate -m \"Add phone number to users\"\nflask db upgrade\n# All 10,000 users are still there, just with a new NULL phone_number column\n</code></pre> <p>Migrations allow you to evolve your database schema over time without losing data. Alembic (handled by Flask-Migrate) generates the SQL commands needed to transform your database from one state to another.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#the-migration-workflow-when-to-run-each-command","title":"The Migration Workflow: When to Run Each Command","text":"<p>[!IMPORTANT] You do NOT need to run all 3 commands every time! Here's when to use each:</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#1-flask-db-init-initialize-migrations-once-per-project","title":"1. <code>flask db init</code> - Initialize Migrations (ONCE per project)","text":"<pre><code>flask db init\n</code></pre> <p>When to run: Only once when you're setting up migrations for the first time in a project.</p> <p>What it does: Creates a <code>migrations/</code> folder with Alembic configuration.</p> <p>You've already run this if: You see a <code>migrations/</code> directory in your project.</p> <p>[!WARNING] Do NOT run <code>flask db init</code> multiple times! If you do, delete the <code>migrations/</code> folder first.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#2-flask-db-migrate-generate-migration-script-when-models-change","title":"2. <code>flask db migrate</code> - Generate Migration Script (When models change)","text":"<pre><code>flask db migrate -m \"Descriptive message about the change\"\n</code></pre> <p>When to run: Every time you modify a model (add/remove columns, add new models, etc.).</p> <p>What it does:</p> <ul> <li>Compares your Python models to the current database schema</li> <li>Generates a Python migration file in <code>migrations/versions/</code></li> <li>Does NOT change your database yet!</li> </ul> <p>Example scenarios:</p> <ul> <li>Added a new column: <code>flask db migrate -m \"Add phone to user\"</code></li> <li>Created a new model: <code>flask db migrate -m \"Add Product model\"</code></li> <li>Removed a column: <code>flask db migrate -m \"Remove deprecated status field\"</code></li> </ul> <p>Important: Always review the generated file before running <code>upgrade</code>!</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#3-flask-db-upgrade-apply-migration-after-migrate-or-when-deploying","title":"3. <code>flask db upgrade</code> - Apply Migration (After migrate, or when deploying)","text":"<pre><code>flask db upgrade\n</code></pre> <p>When to run:</p> <ul> <li>After running <code>flask db migrate</code> to apply your changes locally</li> <li>When deploying to production/staging (to update their databases)</li> <li>After pulling code from teammates who added migrations</li> </ul> <p>What it does: Executes the migration scripts and actually modifies your database.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#complete-example-adding-a-column","title":"Complete Example: Adding a Column","text":"<p>Let's say you want to add a <code>phone_number</code> field to your User model.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#step-1-modify-your-model","title":"Step 1: Modify your model","text":"<pre><code># models.py\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), nullable=False)\n    email = db.Column(db.String(120), nullable=False)\n    phone_number = db.Column(db.String(20))  # New field!\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#step-2-generate-migration","title":"Step 2: Generate migration","text":"<pre><code>flask db migrate -m \"Add phone number to users\"\n</code></pre> <p>Output:</p> <pre><code>INFO  [alembic.autogenerate.compare] Detected added column 'users.phone_number'\nGenerating /path/to/migrations/versions/abc123_add_phone_number_to_users.py ... done\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#step-3-apply-migration","title":"Step 3: Apply migration","text":"<pre><code>flask db upgrade\n</code></pre> <p>Output:</p> <pre><code>INFO  [alembic.runtime.migration] Running upgrade -&gt; abc123, Add phone number to users\n</code></pre> <p>Done! Your database now has the <code>phone_number</code> column.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#common-mistakes-juniors-make","title":"Common Mistakes Juniors Make","text":"<ol> <li>\u274c Running all 3 commands every time</li> </ol> <p><code>bash    # WRONG - Don't do this!    flask db init    # Only run once ever    flask db migrate    flask db upgrade</code></p> <ol> <li>\u274c Forgetting to import models in app.py</li> </ol> <p>Result: <code>flask db migrate</code> says \"No changes detected\" even though you modified models.</p> <p>Fix: Make sure you imported your models in <code>app.py</code> as shown in the Configuration section.</p> <ol> <li>\u274c Running <code>upgrade</code> without <code>migrate</code> first</li> </ol> <p>Result: No new migration file, so <code>upgrade</code> does nothing.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#troubleshooting","title":"Troubleshooting","text":"<p>Problem: \"No changes detected\" even though I modified my model.</p> <p>Solutions:</p> <ul> <li>Did you import the model in <code>app.py</code>?</li> <li>Did you save the <code>models.py</code> file?</li> <li>Try: <code>flask db migrate -m \"Force migration\" --autogenerate</code></li> </ul> <p>Problem: \"Can't locate revision identified by 'xyz'\"</p> <p>Solution: Your <code>migrations/</code> folder is out of sync. In development, you can:</p> <ol> <li>Delete <code>migrations/</code> folder</li> <li>Delete <code>app.db</code></li> <li>Run <code>flask db init</code>, then <code>flask db migrate</code>, then <code>flask db upgrade</code></li> </ol>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#sqlalchemy-fundamentals-crud-operations","title":"SQLAlchemy Fundamentals: CRUD Operations","text":"<p>Before we jump into Services, you need to know how to actually use SQLAlchemy to work with data. This section teaches you the basics.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#the-database-session","title":"The Database Session","text":"<p>SQLAlchemy uses a session (<code>db.session</code>) to manage database operations. Think of it like a shopping cart:</p> <ul> <li>You add items (records) to the cart (<code>db.session.add()</code>)</li> <li>When ready, you checkout (<code>db.session.commit()</code>)</li> <li>If you change your mind, you can empty the cart (<code>db.session.rollback()</code>)</li> </ul>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#create-adding-new-records","title":"Create: Adding New Records","text":"<pre><code>from models import User\nfrom extensions import db\n\n# Create a new user object\nnew_user = User(\n    username=\"alice\",\n    email=\"alice@example.com\",\n    password_hash=\"hashed_password_here\"\n)\n\n# Add to session (not saved yet!)\ndb.session.add(new_user)\n\n# Commit to database (now it's saved)\ndb.session.commit()\n\n# After commit, the user object gets its ID from the database\nprint(new_user.id)  # e.g., 1\n</code></pre> <p>Adding multiple records:</p> <pre><code>users = [\n    User(username=\"bob\", email=\"bob@example.com\", password_hash=\"hash1\"),\n    User(username=\"charlie\", email=\"charlie@example.com\", password_hash=\"hash2\")\n]\n\ndb.session.add_all(users)\ndb.session.commit()\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#read-querying-data","title":"Read: Querying Data","text":"<p>SQLAlchemy provides a powerful query API. Here are the essentials:</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#get-all-records","title":"Get All Records","text":"<pre><code># Get all users\nusers = User.query.all()\nfor user in users:\n    print(user.username)\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#get-by-primary-key","title":"Get by Primary Key","text":"<pre><code># Get user with ID = 1\nuser = User.query.get(1)\nif user:\n    print(user.username)\nelse:\n    print(\"User not found\")\n</code></pre> <p>Or safer with <code>get_or_404</code> (if using in routes):</p> <pre><code>from flask import abort\n\nuser = User.query.get_or_404(1)  # Auto-returns 404 if not found\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#filter-records","title":"Filter Records","text":"<pre><code># Get all users with a specific username\nusers = User.query.filter_by(username=\"alice\").all()\n\n# Get first user matching condition\nuser = User.query.filter_by(email=\"alice@example.com\").first()\nif not user:\n    print(\"No user found\")\n</code></pre> <p>Multiple conditions:</p> <pre><code># Find active users named Alice\nusers = User.query.filter_by(username=\"alice\", is_active=True).all()\n</code></pre> <p>Complex filters:</p> <pre><code># Using filter() for more complex conditions\nusers = User.query.filter(User.username.like('%alice%')).all()\n\n# Multiple conditions with filter()\nusers = User.query.filter(\n    User.is_active == True,\n    User.email.contains('@example.com')\n).all()\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#count-records","title":"Count Records","text":"<pre><code>total_users = User.query.count()\nactive_users = User.query.filter_by(is_active=True).count()\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#order-results","title":"Order Results","text":"<pre><code># Order by username ascending\nusers = User.query.order_by(User.username).all()\n\n# Order by ID descending\nusers = User.query.order_by(User.id.desc()).all()\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#limit-results","title":"Limit Results","text":"<pre><code># Get first 10 users\nusers = User.query.limit(10).all()\n\n# Skip first 20, then get next 10 (pagination)\nusers = User.query.offset(20).limit(10).all()\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#update-modifying-existing-records","title":"Update: Modifying Existing Records","text":"<pre><code># Get the user\nuser = User.query.get(1)\n\nif user:\n    # Modify attributes\n    user.email = \"newemail@example.com\"\n    user.is_active = False\n\n    # Commit changes\n    db.session.commit()\n</code></pre> <p>Bulk update:</p> <pre><code># Update all inactive users to active\nUser.query.filter_by(is_active=False).update({\"is_active\": True})\ndb.session.commit()\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#delete-removing-records","title":"Delete: Removing Records","text":"<pre><code># Get the user\nuser = User.query.get(1)\n\nif user:\n    db.session.delete(user)\n    db.session.commit()\n</code></pre> <p>Bulk delete:</p> <pre><code># Delete all inactive users\nUser.query.filter_by(is_active=False).delete()\ndb.session.commit()\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#error-handling-with-rollback","title":"Error Handling with Rollback","text":"<p>If something goes wrong, you can rollback the session:</p> <pre><code>try:\n    new_user = User(username=\"alice\", email=\"alice@example.com\")\n    db.session.add(new_user)\n    db.session.commit()\nexcept Exception as e:\n    db.session.rollback()  # Undo all changes\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#quick-reference-sqlalchemy-crud","title":"Quick Reference: SQLAlchemy CRUD","text":"Operation Code Example Create <code>db.session.add(obj)</code> + <code>db.session.commit()</code> Read All <code>Model.query.all()</code> Read One <code>Model.query.get(id)</code> or <code>.first()</code> Filter <code>Model.query.filter_by(field=value).all()</code> Update <code>obj.field = new_value</code> + <code>db.session.commit()</code> Delete <code>db.session.delete(obj)</code> + <code>db.session.commit()</code> Rollback <code>db.session.rollback()</code>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#the-service-layer-pattern","title":"The Service Layer Pattern","text":"<p>This is the most important architectural rule in our project.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#concept-classes-as-namespaces","title":"\ud83e\udde0 Concept: Classes as Namespaces","text":"<p>We use <code>class UserService</code>. Don't panic. We are not creating objects (<code>user_service = UserService()</code>).</p> <p>We are just using the class as a Namespace (like a folder) to group related functions together.</p> <ul> <li><code>UserService.create_user()</code></li> <li><code>UserService.get_all_users()</code></li> </ul> <p>It keeps our code organized. Pure functions would work too, but this is the Flask/Python industry standard.</p> <p>You can think of it as two equivalent styles:</p> <pre><code># Pure functions (no classes)\ndef create_user(username, email):\n    ...\n\ndef get_all_users():\n    ...\n</code></pre> <pre><code># Same idea, grouped in a class-as-namespace\nclass UserService:\n    @staticmethod\n    def create_user(username, email):\n        ...\n\n    @staticmethod\n    def get_all_users():\n        ...\n</code></pre> <p>In this course we mostly use the second style because it scales better in real projects, but you do not need to learn constructors, inheritance, or polymorphism. If you ever feel stuck, revisit the OOP FAQ in the main Flask Learning Guide and remember that classes here are just organized folders for related functions.</p> <p>[!TIP] If you see confusing errors around <code>self</code> or class methods, double-check that your service methods are marked with <code>@staticmethod</code> and that you are calling them like <code>UserService.create_user(...)</code> (without creating an instance).</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#the-bad-way-fat-routes","title":"\u274c The Bad Way (Fat Routes)","text":"<p>Do NOT do this:</p> <pre><code># BAD CODE - DO NOT USE\n@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    # Business logic in route!\n    if User.query.filter_by(email=data['email']).first():\n        return jsonify({\"error\": \"Email exists\"}), 400\n\n    # DB access in route!\n    new_user = User(username=data['username'], email=data['email'])\n    db.session.add(new_user)\n    db.session.commit()\n\n    return jsonify({\"id\": new_user.id}), 201\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#the-good-way-thin-routes-service-layer","title":"\u2705 The Good Way (Thin Routes + Service Layer)","text":"<p>You can implement the Service Layer using either classes or functions. Both are correct!</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#option-1-class-based-service-recommended","title":"Option 1: Class-Based Service (Recommended)","text":"<p>1. Create the Service (<code>services/user_service.py</code>)</p> <pre><code>from models import User\nfrom extensions import db\n\nclass UserService:\n    @staticmethod\n    def create_user(username, email, password_hash):\n        \"\"\"\n        Handles business logic for creating a user.\n        \"\"\"\n        # Validation Logic\n        if User.query.filter_by(email=email).first():\n            return None, \"Email already exists\"\n\n        # DB Logic\n        new_user = User(username=username, email=email, password_hash=password_hash)\n        db.session.add(new_user)\n        db.session.commit()\n\n        return new_user, None\n\n    @staticmethod\n    def get_all_users():\n        return User.query.all()\n</code></pre> <p>2. Call it from the Route (<code>app.py</code>)</p> <pre><code>from flask import Flask, request, jsonify\nfrom extensions import db\nfrom models import User\nfrom services.user_service import UserService\n\napp = Flask(__name__)\n# ... app configuration ...\n\n@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n\n    # Route just delegates to Service\n    user, error = UserService.create_user(\n        username=data['username'],\n        email=data['email'],\n        password_hash=data['password'],  # In real app, hash this first!\n    )\n\n    if error:\n        return jsonify({\"error\": error}), 400\n\n    return jsonify({\"id\": user.id, \"message\": \"Created\"}), 201\n\n\n@app.route('/users', methods=['GET'])\ndef get_users():\n    users = UserService.get_all_users()\n    return jsonify({\"users\": [{\"id\": u.id, \"username\": u.username} for u in users]}), 200\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#option-2-function-based-service-also-acceptable","title":"Option 2: Function-Based Service (Also Acceptable)","text":"<p>If you're not comfortable with classes, you can use plain functions:</p> <p>1. Create Service Functions (<code>services/user_functions.py</code>)</p> <pre><code>from models import User\nfrom extensions import db\n\ndef create_user(username, email, password_hash):\n    \"\"\"\n    Handles business logic for creating a user.\n    \"\"\"\n    # Validation Logic\n    if User.query.filter_by(email=email).first():\n        return None, \"Email already exists\"\n\n    # DB Logic\n    new_user = User(username=username, email=email, password_hash=password_hash)\n    db.session.add(new_user)\n    db.session.commit()\n\n    return new_user, None\n\n\ndef get_all_users():\n    return User.query.all()\n</code></pre> <p>2. Call it from the Route (<code>app.py</code>)</p> <pre><code>from flask import Flask, request, jsonify\nfrom extensions import db\nfrom models import User\nfrom services.user_functions import create_user, get_all_users\n\napp = Flask(__name__)\n# ... app configuration ...\n\n@app.route('/users', methods=['POST'])\ndef create_user_endpoint():\n    data = request.get_json()\n\n    # Route just delegates to service function\n    user, error = create_user(\n        username=data['username'],\n        email=data['email'],\n        password_hash=data['password'],\n    )\n\n    if error:\n        return jsonify({\"error\": error}), 400\n\n    return jsonify({\"id\": user.id, \"message\": \"Created\"}), 201\n\n\n@app.route('/users', methods=['GET'])\ndef get_users_endpoint():\n    users = get_all_users()\n    return jsonify({\"users\": [{\"id\": u.id, \"username\": u.username} for u in users]}), 200\n</code></pre> <p>[!NOTE] Both approaches achieve the same goal! The class-based approach is industry standard for larger projects, but function-based works perfectly. Choose what you're comfortable with.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#why","title":"Why?","text":"<ol> <li>Reusability: You can call <code>UserService.create_user</code> from a CLI command or a test or another service.</li> <li>Testing: You can test <code>UserService</code> without faking HTTP requests.</li> <li>Maintainability: Routes stay simple and clean.</li> </ol>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#refactoring-the-right-way","title":"Refactoring: The Right Way","text":"<p>When you have existing code with fat routes (business logic and database calls in routes), here's how to refactor it properly:</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#step-by-step-refactoring-process","title":"Step-by-Step Refactoring Process","text":"<ol> <li>Identify the Logic: Find all business logic and database operations in your routes</li> <li>Extract to Service: Move that logic to a service method</li> <li>Update Route: Make the route call the service method</li> <li>Test: Verify the behavior remains the same</li> </ol>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#example-refactoring-a-create-endpoint","title":"Example: Refactoring a Create Endpoint","text":"<p>Before (Fat Route):</p> <pre><code>@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    # Validation in route\n    if User.query.filter_by(email=data['email']).first():\n        return jsonify({\"error\": \"Email exists\"}), 400\n    # DB logic in route\n    new_user = User(username=data['username'], email=data['email'])\n    db.session.add(new_user)\n    db.session.commit()\n    return jsonify({\"id\": new_user.id}), 201\n</code></pre> <p>After (Thin Route + Service):</p> <pre><code># In services/user_service.py\nclass UserService:\n    @staticmethod\n    def create_user(username, email):\n        if User.query.filter_by(email=email).first():\n            return None, \"Email already exists\"\n        new_user = User(username=username, email=email)\n        db.session.add(new_user)\n        db.session.commit()\n        return new_user, None\n\n# In app.py\n@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    user, error = UserService.create_user(\n        username=data['username'],\n        email=data['email']\n    )\n    if error:\n        return jsonify({\"error\": error}), 400\n    return jsonify({\"id\": user.id}), 201\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#key-refactoring-principles","title":"Key Refactoring Principles","text":"<ul> <li>One Step at a Time: Refactor one route at a time, test, then move to the next</li> <li>Preserve Behavior: The API should work exactly the same after refactoring</li> <li>Keep It Simple: Don't over-engineer - extract logic, don't add complexity</li> </ul>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#practice-problems","title":"Practice Problems","text":""},{"location":"04_LEVEL_2A_INTERMEDIATE.html#problem-1-book-model","title":"Problem 1: Book Model","text":"<p>Create a <code>Book</code> model with the following fields:</p> <ul> <li><code>title</code> (String, required)</li> <li><code>author</code> (String, required)</li> <li><code>isbn</code> (String, unique)</li> </ul>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#step-1-create-the-model","title":"Step 1: Create the Model","text":"<p>Create <code>models.py</code> (or add to existing):</p> <pre><code># models.py\nfrom extensions import db\n\nclass Book(db.Model):\n    __tablename__ = 'books'\n\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(200), nullable=False)\n    author = db.Column(db.String(100), nullable=False)\n    isbn = db.Column(db.String(13), unique=True, nullable=False)\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#step-2-run-migrations","title":"Step 2: Run Migrations","text":"<pre><code>flask db migrate -m \"Add Book model\"\nflask db upgrade\n</code></pre> <p>Verify the migration was created and the table exists.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#problem-2-book-service","title":"Problem 2: Book Service","text":"<p>Create a <code>BookService</code> with methods:</p> <ul> <li><code>add_book(title, author, isbn)</code></li> <li><code>get_books_by_author(author)</code></li> </ul> <p>Ensure <code>add_book</code> raises an error if ISBN already exists.</p> <p>Starter code:</p> <pre><code># services/book_service.py\nfrom models import Book\nfrom extensions import db\n\nclass BookService:\n    @staticmethod\n    def add_book(title, author, isbn):\n        # Check if ISBN exists\n        existing = Book.query.filter_by(isbn=isbn).first()\n        if existing:\n            return None, \"Book with this ISBN already exists\"\n\n        # Create book\n        book = Book(title=title, author=author, isbn=isbn)\n        db.session.add(book)\n        # Hint: Something is missing here...\n\n        return book, None\n\n    @staticmethod\n    def get_books_by_author(author):\n        return Book.query.filter_by(author=author).all()\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#problem-3-refactor-calculator-to-use-service-pattern","title":"Problem 3: Refactor Calculator to Use Service Pattern","text":"<p>In Level 1, you built a <code>/calculate</code> endpoint that performed operations directly in the route. Now, refactor it to use the Service Layer Pattern.</p> <p>What is \"CalculationService\"?</p> <p>A <code>CalculationService</code> is simply a place to put your calculator logic (add, subtract, multiply, divide) outside of the route function. The route should only:</p> <ol> <li>Get the request data</li> <li>Call the service</li> <li>Return the response</li> </ol> <p>The service does the actual calculation.</p> <p>Why do this?</p> <ul> <li>Testable: You can test calculations without making HTTP requests</li> <li>Reusable: Other parts of your app can use the same calculation functions</li> <li>Clean: Routes stay simple and focused on HTTP handling</li> </ul>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#solution-1-class-based-recommended","title":"Solution 1: Class-Based (Recommended)","text":"<pre><code># services/calculation_service.py\nclass CalculationService:\n    @staticmethod\n    def calculate(operation, x, y):\n        \"\"\"\n        Performs a calculation based on the operation.\n        Raises ValueError if operation is invalid.\n        \"\"\"\n        if operation == \"add\":\n            return x + y\n        elif operation == \"subtract\":\n            return x - y\n        elif operation == \"multiply\":\n            return x * y\n        elif operation == \"divide\":\n            if y == 0:\n                raise ValueError(\"Cannot divide by zero\")\n            return x / y\n        else:\n            raise ValueError(f\"Invalid operation: {operation}\")\n</code></pre> <pre><code># app.py or routes/calculator_routes.py\nfrom flask import Flask, request, jsonify\nfrom services.calculation_service import CalculationService\n\napp = Flask(__name__)\n\n@app.route(\"/calculate\", methods=[\"POST\"])\ndef calculate():\n    data = request.get_json()\n\n    # Validation\n    if not data:\n        return jsonify({\"error\": \"Request body required\"}), 400\n\n    operation = data.get(\"operation\")\n    x = data.get(\"x\")\n    y = data.get(\"y\")\n\n    if not all([operation, x is not None, y is not None]):\n        return jsonify({\"error\": \"Missing operation, x, or y\"}), 400\n\n    # Call the service\n    try:\n        result = CalculationService.calculate(operation, x, y)\n        return jsonify({\"result\": result}), 200\n    except ValueError as e:\n        return jsonify({\"error\": str(e)}), 400\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#solution-2-function-based-also-acceptable","title":"Solution 2: Function-Based (Also Acceptable)","text":"<p>If you're not comfortable with classes yet, you can use plain functions:</p> <pre><code># services/calculation_functions.py\ndef calculate(operation, x, y):\n    \"\"\"\n    Performs a calculation based on the operation.\n    Raises ValueError if operation is invalid.\n    \"\"\"\n    if operation == \"add\":\n        return x + y\n    elif operation == \"subtract\":\n        return x - y\n    elif operation == \"multiply\":\n        return x * y\n    elif operation == \"divide\":\n        if y == 0:\n            raise ValueError(\"Cannot divide by zero\")\n        return x / y\n    else:\n        raise ValueError(f\"Invalid operation: {operation}\")\n</code></pre> <pre><code># app.py or routes/calculator_routes.py\nfrom flask import Flask, request, jsonify\nfrom services.calculation_functions import calculate\n\napp = Flask(__name__)\n\n@app.route(\"/calculate\", methods=[\"POST\"])\ndef calculate_endpoint():\n    data = request.get_json()\n\n    if not data:\n        return jsonify({\"error\": \"Request body required\"}), 400\n\n    operation = data.get(\"operation\")\n    x = data.get(\"x\")\n    y = data.get(\"y\")\n\n    if not all([operation, x is not None, y is not None]):\n        return jsonify({\"error\": \"Missing operation, x, or y\"}), 400\n\n    try:\n        result = calculate(operation, x, y)\n        return jsonify({\"result\": result}), 200\n    except ValueError as e:\n        return jsonify({\"error\": str(e)}), 400\n</code></pre> <p>[!NOTE] Both solutions are correct! The class-based approach is the industry standard for larger projects, but the function-based approach works perfectly fine. Choose whichever you're more comfortable with.</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#common-pitfalls-quiz","title":"Common Pitfalls Quiz","text":"<p>Test your understanding of database and architecture mistakes:</p>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#pitfall-1-forgetting-dbsessioncommit","title":"Pitfall 1: Forgetting db.session.commit()","text":"<p>Question: Why doesn't the user get created?</p> <pre><code>from models import User\nfrom extensions import db\n\n@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    user = User(username=data['username'], email=data['email'])\n    db.session.add(user)\n    # Missing commit!\n    return jsonify({\"message\": \"Created\"}), 201\n</code></pre> Click to see answer  **Answer**: Changes are only written to the database when you call `db.session.commit()`. Without it, changes stay in memory and are lost.  **Fix**:   <pre><code>@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    user = User(username=data['username'], email=data['email'])\n    db.session.add(user)\n    db.session.commit()  # Actually save to database!\n    return jsonify({\"message\": \"Created\"}), 201\n</code></pre>    **Remember**: SQLAlchemy uses a \"Unit of Work\" pattern:  1. `db.session.add()` - Stage changes 2. `db.session.commit()` - Write to database"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#pitfall-2-running-flask-db-init-multiple-times","title":"Pitfall 2: Running flask db init Multiple Times","text":"<p>Question: What happens?</p> <pre><code>$ flask db init\n# Creates migrations/ folder\n$ flask db init  # Run again by mistake\nError: Directory migrations already exists\n</code></pre> Click to see answer  **Answer**: `flask db init` should only be run **ONCE** per project. It creates the `migrations/` folder structure.  **If you need to start fresh**:   <pre><code># Delete everything and start over (DEVELOPMENT ONLY!)\nrm -rf migrations/\nrm app.db\nflask db init\nflask db migrate -m \"Initial migration\"\nflask db upgrade\n</code></pre>    **Remember**:  - `flask db init` - Once per project - `flask db migrate` - Every time models change - `flask db upgrade` - After migrate, and when deploying"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#pitfall-3-forgetting-to-import-models","title":"Pitfall 3: Forgetting to Import Models","text":"<p>Question: Why does <code>flask db migrate</code> say \"No changes detected\"?</p> <pre><code># app.py\nfrom flask import Flask\nfrom extensions import db, migrate\n\ndef create_app():\n    app = Flask(__name__)\n    db.init_app(app)\n    migrate.init_app(app, db)\n    # Forgot to import models!\n    return app\n\n# models.py\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80))\n</code></pre> Click to see answer  **Answer**: Flask-Migrate can't detect models you haven't imported! If Python doesn't load the model class, Alembic doesn't know it exists.  **Fix**:   <pre><code># app.py\nfrom flask import Flask\nfrom extensions import db, migrate\nfrom models import User  # Import all models!\n\ndef create_app():\n    app = Flask(__name__)\n    db.init_app(app)\n    migrate.init_app(app, db)\n    return app\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#pitfall-4-putting-database-logic-in-routes","title":"Pitfall 4: Putting Database Logic in Routes","text":"<p>Question: What's wrong with this architecture?</p> <pre><code>@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n\n    # Business logic in route!\n    if User.query.filter_by(email=data['email']).first():\n        return jsonify({\"error\": \"Email exists\"}), 400\n\n    # Database calls in route!\n    user = User(username=data['username'], email=data['email'])\n    db.session.add(user)\n    db.session.commit()\n\n    return jsonify({\"id\": user.id}), 201\n</code></pre> Click to see answer  **Answer**: **FAT ROUTES ARE BAD!** This violates the Service Layer pattern. Routes should only handle HTTP, not business logic or database calls.  **Fix with Service Layer**:   <pre><code># services/user_service.py\nclass UserService:\n    @staticmethod\n    def create_user(username, email):\n        if User.query.filter_by(email=email).first():\n            return None, \"Email exists\"\n\n        user = User(username=username, email=email)\n        db.session.add(user)\n        db.session.commit()\n        return user, None\n\n# app.py\n@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    user, error = UserService.create_user(data['username'], data['email'])\n\n    if error:\n        return jsonify({\"error\": error}), 400\n    return jsonify({\"id\": user.id}), 201\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#pitfall-5-circular-import-hell","title":"Pitfall 5: Circular Import Hell","text":"<p>Question: Why does this crash with ImportError?</p> <pre><code># app.py\nfrom extensions import db\nfrom models import User\n\napp = Flask(__name__)\ndb.init_app(app)\n\n# models.py\nfrom app import db  # Circular import!\n\nclass User(db.Model):\n    pass\n</code></pre> Click to see answer  **Answer**: Circular import! `app.py` imports `models.py`, and `models.py` tries to import `app.py`.  **Fix with extensions.py**:   <pre><code># extensions.py\nfrom flask_sqlalchemy import SQLAlchemy\ndb = SQLAlchemy()\n\n# models.py\nfrom extensions import db  # Import from extensions!\n\nclass User(db.Model):\n    pass\n\n# app.py\nfrom extensions import db\nfrom models import User\n\ndef create_app():\n    app = Flask(__name__)\n    db.init_app(app)\n    return app\n</code></pre>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#trivia","title":"Trivia","text":""},{"location":"04_LEVEL_2A_INTERMEDIATE.html#question-1","title":"Question 1","text":"<p>Where should database queries reside?</p> <ul> <li>[ ] In the Route function</li> <li>[ ] In the Template</li> <li>[x] In the Service Layer</li> <li>[ ] In the <code>app.py</code></li> </ul>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#question-2","title":"Question 2","text":"<p>What command applies changes to the database?</p> <ul> <li>[ ] <code>flask db init</code></li> <li>[ ] <code>flask db migrate</code></li> <li>[x] <code>flask db upgrade</code></li> <li>[ ] <code>flask run</code></li> </ul>"},{"location":"04_LEVEL_2A_INTERMEDIATE.html#question-3","title":"Question 3","text":"<p>Why do we avoid \"Fat Routes\"?</p> <ul> <li>[ ] They take up too much disk space</li> <li>[x] They mix business logic with HTTP logic, making code hard to test and reuse</li> <li>[ ] Flask forbids them</li> </ul>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html","title":"Level 2B: Intermediate - Serialization &amp; Error Handling","text":"<p>Prerequisites: Level 2A: Databases Next Level: Level 3: Authentication</p> <p>[!NOTE] OOP Level: Low. Schemas are classes, but they are just templates for data shapes. You declare fields, and Marshmallow does the magic. You do not need to understand advanced OOP concepts to use them.</p>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#goal","title":"Goal","text":"<p>In this level, we make our API robust. We will use Marshmallow for validation (incoming data) and serialization (outgoing data). We will also strictly implement Global Error Handling so users never see standard internal server errors.</p> <p>Strict Rules:</p> <ol> <li>Never return Model objects directly: Always serialize them to JSON.</li> <li>Never expose Stack Traces: Catch all errors and return generic JSON messages.</li> <li>Validate Inputs: Trust no one.</li> </ol>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#table-of-contents","title":"Table of Contents","text":"<ol> <li>Why Marshmallow?</li> <li>Defining Schemas</li> <li>Validation (Input)</li> <li>Serialization (Output)</li> <li>Global Error Handling</li> <li>Practice Problems</li> </ol>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#why-marshmallow","title":"Why Marshmallow?","text":"<p>SQLAlchemy Models are Python Objects. APIs need JSON. Marshmallow bridges this gap.</p> <ul> <li>Serialization: Object -&gt; JSON</li> <li>Deserialization: JSON -&gt; Object (with Validation!)</li> </ul> <p>Install it:</p> <pre><code>pip install flask-marshmallow marshmallow-sqlalchemy\n</code></pre>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#defining-schemas","title":"Defining Schemas","text":"<p>Schemas usually sit near your models or in a <code>schemas/</code> folder.</p> <pre><code>from flask_marshmallow import Marshmallow\nfrom marshmallow import ValidationError\nfrom models import User\n\nma = Marshmallow()\n\nclass UserSchema(ma.SQLAlchemyAutoSchema):\n    class Meta:\n        model = User\n        load_instance = True  # Optional: deserialize to model instances\n        exclude = (\"password_hash\",)  # Never expose password hashes\n\n# Initialize schemas\nuser_schema = UserSchema()\nusers_schema = UserSchema(many=True)\n</code></pre> <p>[!TIP] Magic Box \u2013 Schemas &amp; <code>ma</code>: Treat <code>ma = Marshmallow()</code> and <code>class UserSchema(...)</code> as Magic Boxes that know how to turn your models into JSON and validate input. Focus on which fields you declare and what errors you return, not on how Marshmallow works internally.</p>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#validation-input","title":"Validation (Input)","text":"<p>Use the schema to validate incoming JSON before it reaches your Service Layer.</p> <pre><code>@app.route('/users', methods=['POST'])\ndef create_user():\n    json_data = request.get_json()\n\n    try:\n        # Validate data\n        data = user_schema.load(json_data)\n    except ValidationError as err:\n        return jsonify(err.messages), 400\n\n    # Proceed to service...\n    user = UserService.create_user(\n        username=data[\"username\"],\n        email=data[\"email\"],\n        password_hash=data[\"password_hash\"],\n    )\n</code></pre>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#serialization-output","title":"Serialization (Output)","text":"<p>Never manually build dictionaries like <code>{'id': user.id, ...}</code>. Use the schema.</p> <pre><code>@app.route('/users', methods=['GET'])\ndef get_users():\n    users = UserService.get_all_users()\n\n    # Dump list of users\n    result = users_schema.dump(users)\n    return jsonify(result), 200\n\n@app.route('/users/&lt;int:id&gt;', methods=['GET'])\ndef get_user(id):\n    user = UserService.get_user_by_id(id)\n\n    # Dump single user\n    result = user_schema.dump(user)\n    return jsonify(result), 200\n</code></pre>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#global-error-handling","title":"Global Error Handling","text":"<p>Rule: User should not be able to see the internal server errors on UI.</p> <p>Instead of <code>try-except</code> in every route, use <code>errorhandler</code>.</p>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#1-create-a-custom-exception","title":"1. Create a Custom Exception","text":"<pre><code># errors.py\n\nclass AppError(Exception):\n    def __init__(self, message, status_code=400):\n        super().__init__(message)\n        self.message = message\n        self.status_code = status_code\n</code></pre>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#2-update-service-to-raise-it","title":"2. Update Service to raise it","text":"<pre><code># services/user_service.py\nfrom errors import AppError\n\ndef get_user_by_id(user_id):\n    user = User.query.get(user_id)\n    if not user:\n        raise AppError(\"User not found\", 404)\n    return user\n</code></pre>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#3-catch-it-globally-in-apppy","title":"3. Catch it Globally in <code>app.py</code>","text":"<pre><code>from errors import AppError\n\ndef create_app():\n    app = Flask(__name__)\n    # ... config ...\n\n    @app.errorhandler(AppError)\n    def handle_app_error(e):\n        return jsonify({\n            \"error\": e.message,\n            \"code\": e.status_code\n        }), e.status_code\n\n    @app.errorhandler(500)\n    def handle_500(e):\n        # Log the real error to a file/logging service\n        # app.logger.error(e)\n        return jsonify({\"error\": \"Internal Server Error\"}), 500\n\n    @app.errorhandler(404)\n    def handle_404(e):\n        return jsonify({\"error\": \"Resource not found\"}), 404\n\n    return app\n</code></pre> <p>Result: Even if your code crashes, the user sees <code>{\"error\": \"Internal Server Error\"}</code> (JSON), not a scary HTML stack trace.</p>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#practice-problems","title":"Practice Problems","text":""},{"location":"05_LEVEL_2B_INTERMEDIATE.html#problem-1-book-schema","title":"Problem 1: Book Schema","text":"<p>Create a <code>BookSchema</code> for your Book model. Configure it to auto-generate from the SQLAlchemy model.</p>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#problem-2-serialize-user-list","title":"Problem 2: Serialize User List","text":"<p>Create an endpoint <code>/api/users</code> that returns all users as JSON using Marshmallow.</p> <p>Starter code:</p> <pre><code>from flask import Flask, jsonify\nfrom models import User\nfrom schemas import UserSchema\n\napp = Flask(__name__)\n\nuser_schema = UserSchema()\nusers_schema = UserSchema(many=True)\n\n@app.route('/api/users', methods=['GET'])\ndef get_users():\n    users = User.query.all()\n    # Serialize the users\n    result = users_schema.load(users)  # Is this correct?\n    return jsonify(result), 200\n</code></pre>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#problem-3-validate-implementation","title":"Problem 3: Validate Implementation","text":"<p>Update your <code>create_book</code> route to use <code>book_schema.load()</code>. Try sending invalid data (missing title) and confirm you get a 400 JSON response with validation errors.</p>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#problem-4-404-handler","title":"Problem 4: 404 Handler","text":"<p>Implement a global 404 handler that returns <code>{\"error\": \"This endpoint does not exist\"}</code>. Use Postman to trigger it.</p>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#common-pitfalls-quiz","title":"Common Pitfalls Quiz","text":"<p>Test your understanding of serialization and validation:</p>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#pitfall-1-exposing-sensitive-fields","title":"Pitfall 1: Exposing Sensitive Fields","text":"<p>Question: What's wrong with this schema?</p> <pre><code>from marshmallow import Schema, fields\n\nclass UserSchema(ma.SQLAlchemyAutoSchema):\n    class Meta:\n        model = User\n        load_instance = True\n        # No exclusions!\n</code></pre> Click to see answer  **Answer**: This exposes **password_hash** in API responses! Anyone can see hashed passwords.  **Fix**:   <pre><code>class UserSchema(ma.SQLAlchemyAutoSchema):\n    class Meta:\n        model = User\n        load_instance = True\n        exclude = (\"password_hash\",)  # Never expose passwords!\n</code></pre>    **Critical security rule**: NEVER expose:  - `password_hash` - `password` - API keys - Tokens - Internal IDs you don't want users to know"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#pitfall-2-confusing-load-vs-dump","title":"Pitfall 2: Confusing load() vs dump()","text":"<p>Question: Why does this crash?</p> <pre><code>@app.route('/users', methods=['GET'])\ndef get_users():\n    users = User.query.all()\n    result = user_schema.load(users)  # Wrong method!\n    return jsonify(result), 200\n</code></pre> Click to see answer  **Answer**: `load()` is for **input** (JSON \u2192 Object), `dump()` is for **output** (Object \u2192 JSON). You're trying to load when you should dump!  **Fix**:   <pre><code>@app.route('/users', methods=['GET'])\ndef get_users():\n    users = User.query.all()\n    result = users_schema.dump(users)  # dump = serialize for output\n    return jsonify(result), 200\n</code></pre>    **Remember**:  - `schema.load(json_data)` - Validate input, deserialize - `schema.dump(model_object)` - Serialize for output"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#pitfall-3-not-catching-validationerror","title":"Pitfall 3: Not Catching ValidationError","text":"<p>Question: What happens when a user sends invalid data?</p> <pre><code>from marshmallow import ValidationError\n\n@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    validated = user_schema.load(data)  # What if validation fails?\n    # ... create user ...\n    return jsonify({\"message\": \"Created\"}), 201\n</code></pre> Click to see answer  **Answer**: If validation fails, Marshmallow raises `ValidationError`, which crashes your app with a 500 error instead of returning proper 400.  **Fix**:   <pre><code>from marshmallow import ValidationError\n\n@ app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n\n    try:\n        validated = user_schema.load(data)\n    except ValidationError as err:\n        return jsonify(err.messages), 400  # Return validation errors\n\n    # ... create user ...\n    return jsonify({\"message\": \"Created\"}), 201\n</code></pre>    **Better with global handler**:   <pre><code>@app.errorhandler(ValidationError)\ndef handle_validation_error(e):\n    return jsonify(e.messages), 400\n</code></pre>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#pitfall-4-exposing-internal-errors","title":"Pitfall 4: Exposing Internal Errors","text":"<p>Question: What's wrong with this error handler?</p> <pre><code>@app.errorhandler(500)\ndef handle_500(e):\n    return jsonify({\"error\": str(e)}), 500  # Exposing internal details!\n</code></pre> Click to see answer  **Answer**: **NEVER expose internal errors to users!** This leaks:  - Database schema details - File paths - Stack traces - Library versions  Attackers use this information!  **Fix**:   <pre><code>@app.errorhandler(500)\ndef handle_500(e):\n    # Log internally\n    app.logger.error(f\"Internal error: {e}\")\n\n    # Return generic message to user\n    return jsonify({\"error\": \"Internal server error\"}), 500\n</code></pre>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#pitfall-5-wrong-schema-for-different-operations","title":"Pitfall 5: Wrong Schema for Different Operations","text":"<p>Question: How do you handle different requirements for registration vs login?</p> <pre><code># Registration needs: username, email, password\n# Login needs: email, password (no username)\n# Using same schema for both?\n\nclass UserSchema(ma.Schema):\n    username = fields.String(required=True)\n    email = fields.String(required=True)\n    password = fields.String(required=True)\n</code></pre> Click to see answer  **Answer**: Use **different schemas** for different operations!  **Fix**:   <pre><code>class UserRegistrationSchema(ma.Schema):\n    username = fields.String(required=True)\n    email = fields.String(required=True)\n    password = fields.String(required=True)\n\nclass UserLoginSchema(ma.Schema):\n    email = fields.String(required=True)\n    password = fields.String(required=True)\n    # No username needed for login\n\nclass UserResponseSchema(ma.SQLAlchemyAutoSchema):\n    class Meta:\n        model = User\n        exclude = (\"password_hash\",)  # Never return password\n\n# Use appropriate schema\n@app.route('/register', methods=['POST'])\ndef register():\n    data = UserRegistrationSchema().load(request.get_json())\n    # ...\n\n@app.route('/login', methods=['POST'])\ndef login():\n    data = UserLoginSchema().load(request.get_json())\n    # ...\n</code></pre>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#trivia","title":"Trivia","text":""},{"location":"05_LEVEL_2B_INTERMEDIATE.html#question-1","title":"Question 1","text":"<p>What is the method to convert an Object to JSON using Marshmallow?</p> <ul> <li>[ ] <code>schema.load()</code></li> <li>[x] <code>schema.dump()</code></li> <li>[ ] <code>schema.json()</code></li> <li>[ ] <code>schema.serialize()</code></li> </ul>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#question-2","title":"Question 2","text":"<p>What allows us to catch exceptions globally?</p> <ul> <li>[ ] <code>@app.route</code></li> <li>[ ] <code>@app.exception</code></li> <li>[x] <code>@app.errorhandler</code></li> <li>[ ] <code>try...except</code> block in <code>main</code></li> </ul>"},{"location":"05_LEVEL_2B_INTERMEDIATE.html#question-3","title":"Question 3","text":"<p>If a validation error occurs during <code>schema.load()</code>, what exception is raised?</p> <ul> <li>[ ] <code>ValueError</code></li> <li>[x] <code>ValidationError</code></li> <li>[ ] <code>TypeError</code></li> <li>[ ] <code>JsonError</code></li> </ul>"},{"location":"06_LEVEL_3_AUTHENTICATION.html","title":"Level 3: Authentication &amp; Security","text":"<p>Prerequisites: Level 2B: Serialization Next Step: Test Task 2</p> <p>[!NOTE] OOP Level: Medium. We use a class for <code>AuthService</code> as a namespace for auth functions, and decorators like <code>@jwt_required</code> which are advanced functions (not OOP). The complexity in this level is security, not object-oriented design.</p>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#goal","title":"Goal","text":"<p>In this level, we secure our API. Since we are building a stateless JSON API, we will use JWT (JSON Web Tokens) instead of Session-based auth (Flask-Login). We will also implement a strict Authentication Service.</p> <p>Strict Rules:</p> <ol> <li>No Sessions: Use JWTs for API authentication.</li> <li>Passwords: Never store plain passwords. Use Bcrypt.</li> <li>Auth Service: Crypto and Token logic belongs in a service, not the route.</li> </ol>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#table-of-contents","title":"Table of Contents","text":"<ol> <li>Password Hashing</li> <li>JWT Basics</li> <li>The Auth Service</li> <li>Protecting Routes</li> <li>Practice Problems</li> </ol>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#password-hashing","title":"Password Hashing","text":"<p>We need <code>flask-bcrypt</code> to hash passwords.</p>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#setup","title":"Setup","text":"<pre><code>pip install flask-bcrypt\n</code></pre> <p>In <code>extensions.py</code>:</p> <pre><code>from flask_bcrypt import Bcrypt\nbcrypt = Bcrypt()\n</code></pre>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#usage","title":"Usage","text":"<pre><code># Hashing (Registration)\npw_hash = bcrypt.generate_password_hash('s3cret').decode('utf-8')\n\n# Checking (Login)\nis_valid = bcrypt.check_password_hash(pw_hash, 's3cret')\n</code></pre> <p>[!TIP] Magic Box \u2013 Password Hashing (<code>bcrypt</code>): <code>bcrypt.generate_password_hash(...)</code> and <code>bcrypt.check_password_hash(...)</code> are crypto Magic Boxes. You only need to know when to call them (on registration and login), not how hashing works internally.</p>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#jwt-basics","title":"JWT Basics","text":"<p>We use <code>flask-jwt-extended</code> for handling tokens.</p>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#setup_1","title":"Setup","text":"<pre><code>pip install flask-jwt-extended\n</code></pre> <p>In <code>extensions.py</code>:</p> <pre><code>from flask_jwt_extended import JWTManager\njwt = JWTManager()\n</code></pre> <p>In <code>app.py</code> (Factory):</p> <pre><code>def create_app():\n    # ...\n    app.config[\"JWT_SECRET_KEY\"] = \"super-secret-key\"  # Change this!\n    jwt.init_app(app)\n    # ...\n</code></pre> <p>[!TIP] Magic Box \u2013 JWTs: <code>JWTManager</code>, <code>create_access_token</code>, and <code>@jwt_required()</code> are Magic Boxes that handle token creation and verification. Focus on which routes require a token and what payload you store in it, not on the cryptography details.</p>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#the-auth-service","title":"The Auth Service","text":"<p>We must isolate authentication logic.</p>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#servicesauth_servicepy","title":"<code>services/auth_service.py</code>","text":"<pre><code>from models import User, db\nfrom extensions import bcrypt\nfrom flask_jwt_extended import create_access_token\nfrom errors import AppError\n\nclass AuthService:\n    @staticmethod\n    def register_user(username, email, password):\n        # 1. Check if user exists\n        if User.query.filter_by(email=email).first():\n            raise AppError(\"Email already exists\", 400)\n\n        # 2. Hash password\n        password_hash = bcrypt.generate_password_hash(password).decode('utf-8')\n\n        # 3. Create User\n        user = User(username=username, email=email, password_hash=password_hash)\n        db.session.add(user)\n        db.session.commit()\n\n        return user\n\n    @staticmethod\n    def login_user(email, password):\n        # 1. Find User\n        user = User.query.filter_by(email=email).first()\n\n        # 2. Check Password\n        if not user or not bcrypt.check_password_hash(user.password_hash, password):\n            raise AppError(\"Invalid credentials\", 401)\n\n        # 3. Generate Token\n        access_token = create_access_token(identity=user.id)\n        return {\"access_token\": access_token, \"user_id\": user.id}\n</code></pre>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#protecting-routes","title":"Protecting Routes","text":"<p>Now we use the Auth Service in our routes and protect endpoints.</p>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#routesauth_routespy","title":"<code>routes/auth_routes.py</code>","text":"<pre><code>from flask import Blueprint, request, jsonify\nfrom flask_jwt_extended import jwt_required, get_jwt_identity\nfrom services.auth_service import AuthService\nfrom services.user_service import UserService\n\nauth_bp = Blueprint('auth', __name__)\n\n@auth_bp.route('/register', methods=['POST'])\ndef register():\n    data = request.get_json()\n    # Call Service\n    user = AuthService.register_user(\n        data['username'], data['email'], data['password']\n    )\n    return jsonify({\"message\": \"User registered\"}), 201\n\n@auth_bp.route('/login', methods=['POST'])\ndef login():\n    data = request.get_json()\n    # Call Service\n    result = AuthService.login_user(data['email'], data['password'])\n    return jsonify(result), 200\n</code></pre>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#protecting-an-endpoint-jwt_required","title":"Protecting an Endpoint (<code>jwt_required</code>)","text":"<pre><code>@auth_bp.route('/me', methods=['GET'])\n@jwt_required()\ndef get_me():\n    # Get ID from token\n    current_user_id = get_jwt_identity()\n\n    # Use UserService to get details\n    user = UserService.get_user_by_id(current_user_id)\n\n    return jsonify({\"username\": user.username, \"email\": user.email})\n</code></pre>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#common-pitfalls-quiz","title":"Common Pitfalls Quiz","text":"<p>Test your understanding of authentication and security:</p>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#pitfall-1-storing-plain-passwords","title":"Pitfall 1: Storing Plain Passwords","text":"<p>Question: What's wrong with this registration?</p> <pre><code>user = User(username=data['username'], password=data['password'])  # DANGEROUS!\n</code></pre> Click to see answer  **Answer**: **NEVER store plain passwords!** Always hash them with bcrypt.  **Fix**: `password_hash = bcrypt.generate_password_hash(password).decode('utf-8')`"},{"location":"06_LEVEL_3_AUTHENTICATION.html#pitfall-2-forgetting-jwt_required","title":"Pitfall 2: Forgetting @jwt_required()","text":"<p>Question: Why can anyone access this endpoint?</p> <pre><code>@app.route('/admin/users')\ndef get_all_users():\n    return jsonify(users)  # No @jwt_required()!\n</code></pre> Click to see answer  **Answer**: Add `@jwt_required()` decorator to protect endpoints."},{"location":"06_LEVEL_3_AUTHENTICATION.html#pitfall-3-weak-jwt-secret","title":"Pitfall 3: Weak JWT Secret","text":"<p>Question: <code>app.config['JWT_SECRET_KEY'] = 'secret'</code> - what's wrong?</p> Click to see answer  **Answer**: Use strong, random secrets from environment variables, never hardcode!"},{"location":"06_LEVEL_3_AUTHENTICATION.html#practice-problems","title":"Practice Problems","text":""},{"location":"06_LEVEL_3_AUTHENTICATION.html#problem-1-integration","title":"Problem 1: Integration","text":"<p>Install <code>flask-bcrypt</code> and <code>flask-jwt-extended</code>. Update <code>app.py</code> to initialize them.</p>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#problem-2-login-flow","title":"Problem 2: Login Flow","text":"<p>Implement the <code>login</code> route using the <code>AuthService</code>. Test it with Postman:</p> <ol> <li>Register a user (writes to DB with hashed PW).</li> <li>Login with correct password -&gt; Get Token.</li> <li>Login with wrong password -&gt; Get 401 Error.</li> </ol>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#problem-3-protected-route","title":"Problem 3: Protected Route","text":"<p>Create a route <code>/secret</code> that returns <code>{\"message\": \"Top Secret\"}</code>. This should only be accessible to authenticated users.</p> <p>Starter code:</p> <pre><code>from flask import Flask, jsonify\nfrom flask_jwt_extended import get_jwt_identity\n\napp = Flask(__name__)\n\n@app.route('/secret', methods=['GET'])\ndef secret_route():\n    current_user = get_jwt_identity()\n    return jsonify({\"message\": \"Top Secret\", \"user\": current_user}), 200\n</code></pre> <p>Test it:</p> <ol> <li>Try accessing <code>/secret</code> without a token - what happens?</li> <li>Try accessing <code>/secret</code> with a valid token</li> <li>What's missing?</li> </ol>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#trivia","title":"Trivia","text":""},{"location":"06_LEVEL_3_AUTHENTICATION.html#question-1","title":"Question 1","text":"<p>Why do we use JWTs instead of Sessions for APIs?</p> <ul> <li>[x] JWTs are stateless and work well with mobile/frontend apps on potential separate domains.</li> <li>[ ] Sessions are less secure.</li> <li>[ ] JWTs are encrypted (They are signed, not encrypted by default!).</li> <li>[ ] Flask doesn't support sessions.</li> </ul>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#question-2","title":"Question 2","text":"<p>What function generates the hash for a password?</p> <ul> <li>[ ] <code>bcrypt.check_password_hash</code></li> <li>[x] <code>bcrypt.generate_password_hash</code></li> <li>[ ] <code>jwt.create_token</code></li> <li>[ ] <code>hashlib.sha256</code></li> </ul>"},{"location":"06_LEVEL_3_AUTHENTICATION.html#question-3","title":"Question 3","text":"<p>How do you access the user ID inside a protected route?</p> <ul> <li>[ ] <code>request.user_id</code></li> <li>[x] <code>get_jwt_identity()</code></li> <li>[ ] <code>jwt.get_id()</code></li> <li>[ ] <code>current_user.id</code> (This is for Flask-Login)</li> </ul>"},{"location":"07_TEST_TASK_2.html","title":"Flask Test Task 2 \u2013 Relational DB &amp; Service Layer","text":"<p>STOP: Do not attempt this task until you have completed Level 3: Authentication. Next Level: Level 4: Scalable Structure</p> <p>[!TIP] OOP Tip: You will need to create a <code>BookService</code> and <code>AuthorService</code>. Remember, these are just Namespaces (collections of functions). You don't need to do complex OOP inheritance.</p>"},{"location":"07_TEST_TASK_2.html#objective","title":"Objective","text":"<p>Build a Flask-based REST API that interacts with a SQLite database using Flask-SQLAlchemy. This task evaluates:</p> <ul> <li>Database Modeling (One-to-Many relationships)</li> <li>Migration Management</li> <li>Service Layer Pattern (Crucial)</li> <li>Error Handling</li> </ul>"},{"location":"07_TEST_TASK_2.html#problem-statement","title":"Problem Statement","text":"<p>Create a Library Management API that manages <code>Authors</code> and <code>Books</code>.</p> <ul> <li>An <code>Author</code> can have multiple <code>Books</code>.</li> <li>A <code>Book</code> belongs to one <code>Author</code>.</li> </ul>"},{"location":"07_TEST_TASK_2.html#data-models","title":"Data Models","text":""},{"location":"07_TEST_TASK_2.html#author","title":"Author","text":"<ul> <li><code>id</code>: Integer, Primary Key</li> <li><code>name</code>: String, required, unique</li> <li><code>bio</code>: String, optional</li> </ul>"},{"location":"07_TEST_TASK_2.html#book","title":"Book","text":"<ul> <li><code>id</code>: Integer, Primary Key</li> <li><code>title</code>: String, required</li> <li><code>price</code>: Float, required</li> <li><code>author_id</code>: Integer, Foreign Key to <code>Author</code></li> </ul>"},{"location":"07_TEST_TASK_2.html#api-requirements","title":"API Requirements","text":""},{"location":"07_TEST_TASK_2.html#1-create-author","title":"1. Create Author","text":"<p>POST <code>/authors</code></p> <pre><code>{\n  \"name\": \"J.K. Rowling\",\n  \"bio\": \"British author...\"\n}\n</code></pre> <ul> <li>Constraint: Name must be unique. Return 400 if exists.</li> </ul>"},{"location":"07_TEST_TASK_2.html#2-create-book","title":"2. Create Book","text":"<p>POST <code>/books</code></p> <pre><code>{\n  \"title\": \"Harry Potter\",\n  \"price\": 19.99,\n  \"author_id\": 1\n}\n</code></pre> <ul> <li>Validation:</li> <li>Return 400 if <code>author_id</code> field is missing from request body</li> <li>Return 404 if <code>author_id</code> is provided but Author with that ID doesn't exist in database</li> </ul>"},{"location":"07_TEST_TASK_2.html#3-get-author-with-books","title":"3. Get Author with Books","text":"<p>GET <code>/authors/&lt;id&gt;</code></p> <p>Response:</p> <pre><code>{\n  \"id\": 1,\n  \"name\": \"J.K. Rowling\",\n  \"bio\": \"...\",\n  \"books\": [\n    {\"id\": 1, \"title\": \"Harry Potter\", \"price\": 19.99}\n  ]\n}\n</code></pre>"},{"location":"07_TEST_TASK_2.html#4-update-book-price","title":"4. Update Book Price","text":"<p>PUT <code>/books/&lt;id&gt;</code></p> <pre><code>{ \"price\": 25.00 }\n</code></pre>"},{"location":"07_TEST_TASK_2.html#5-delete-author","title":"5. Delete Author","text":"<p>DELETE <code>/authors/&lt;id&gt;</code></p> <ul> <li>Logic: If an author is deleted, all their books should be deleted too (Cascade).</li> </ul>"},{"location":"07_TEST_TASK_2.html#technical-constraints","title":"Technical Constraints","text":"<ol> <li>Service Layer: Logic must exist in <code>services/author_service.py</code> and <code>services/book_service.py</code>. Routes must be thin.</li> <li>Migrations: You must include a <code>migrations</code> folder generated by <code>flask db init</code>.</li> <li>Config: Use <code>sqlite:///library.db</code>.</li> </ol>"},{"location":"07_TEST_TASK_2.html#hints","title":"Hints","text":""},{"location":"07_TEST_TASK_2.html#model-relationships","title":"Model Relationships","text":"<p>Use the pattern from Level 2A:</p> <pre><code># models.py\nclass Author(db.Model):\n    books = db.relationship('Book', backref='author', cascade='all, delete-orphan')\n\nclass Book(db.Model):\n    author_id = db.Column(db.Integer, db.ForeignKey('authors.id'), nullable=False)\n</code></pre>"},{"location":"07_TEST_TASK_2.html#manual-serialization-no-nested-schemas-needed","title":"Manual Serialization (No Nested Schemas Needed!)","text":"<p>For GET /authors/, use manual serialization: <pre><code>@app.route('/authors/&lt;int:id&gt;', methods=['GET'])\ndef get_author(id):\n    author = Author.query.get_or_404(id)\n\n    return jsonify({\n        \"id\": author.id,\n        \"name\": author.name,\n        \"bio\": author.bio,\n        \"books\": [\n            {\"id\": b.id, \"title\": b.title, \"price\": b.price} \n            for b in author.books\n        ]\n    }), 200\n</code></pre> <p>This avoids complex nested Marshmallow schemas while still returning the required format.</p>"},{"location":"07_TEST_TASK_2.html#testing-cascade-delete","title":"Testing Cascade Delete","text":"<ol> <li>Create an author with 2 books</li> <li>DELETE the author</li> <li>Verify both books are also deleted (check database or try to GET the books)</li> </ol>"},{"location":"07_TEST_TASK_2.html#expected-deliverables","title":"Expected Deliverables","text":"<ul> <li><code>app.py</code></li> <li><code>models.py</code></li> <li><code>services/</code></li> <li><code>migrations/</code></li> <li><code>requirements.txt</code></li> </ul>"},{"location":"08_LEVEL_4_SCALABLE.html","title":"Level 4: Scalable Structure &amp; The Application Factory","text":"<p>Prerequisites: Test Task 2 Next Step: Test Task 3 (Conclusion)</p> <p>[!NOTE] OOP Level: Medium. The \"Application Factory\" (<code>create_app</code>) is a function that creates an object (<code>app</code>). You still do not write new classes here\u2014this level is about project structure and imports, not advanced OOP.</p>"},{"location":"08_LEVEL_4_SCALABLE.html#goal","title":"Goal","text":"<p>In this level, we graduate from \"Scripts\" to \"Applications\". We will learn the Application Factory Pattern to allow running multiple instances (dev, test, prod). Most importantly, we will solve the #1 beginner nightmare: Circular Imports.</p>"},{"location":"08_LEVEL_4_SCALABLE.html#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to Blueprints</li> <li>The Circular Import Problem</li> <li>The Application Factory Pattern</li> <li>Project Directory Structure</li> <li>Managing Extensions</li> <li>Configuration Management</li> <li>Practice Problems</li> </ol>"},{"location":"08_LEVEL_4_SCALABLE.html#introduction-to-blueprints","title":"Introduction to Blueprints","text":"<p>Before we can build scalable apps, we need to stop writing everything in one file. Blueprints allow you to organize your routes into separate files (modules).</p>"},{"location":"08_LEVEL_4_SCALABLE.html#directory-structure","title":"Directory Structure","text":"<pre><code>project/\n\u251c\u2500\u2500 app.py\n\u2514\u2500\u2500 routes/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 user_routes.py\n</code></pre>"},{"location":"08_LEVEL_4_SCALABLE.html#1-create-a-blueprint-routesuser_routespy","title":"1. Create a Blueprint (<code>routes/user_routes.py</code>)","text":"<pre><code>from flask import Blueprint, jsonify\n\n# Define the blueprint\nuser_bp = Blueprint(\"users\", __name__, url_prefix=\"/users\")\n\n@user_bp.route(\"/\", methods=[\"GET\"])\ndef get_users():\n    return jsonify({\"users\": []})\n\n@user_bp.route(\"/&lt;int:id&gt;\", methods=[\"GET\"])\ndef get_user(id):\n    return jsonify({\"id\": id})\n</code></pre> <p>[!TIP] Magic Box \u2013 Blueprints: <code>Blueprint(...)</code> and <code>app.register_blueprint(...)</code> are wiring Magic Boxes. Treat them as a standard pattern for grouping routes and attaching them to the app.</p>"},{"location":"08_LEVEL_4_SCALABLE.html#2-register-it-in-apppy","title":"2. Register it in <code>app.py</code>","text":"<pre><code>from flask import Flask\nfrom routes.user_routes import user_bp\n\napp = Flask(__name__)\n\n# Register the blueprint\napp.register_blueprint(user_bp)\n# Now routes are accessible at /users and /users/&lt;id&gt;\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre>"},{"location":"08_LEVEL_4_SCALABLE.html#the-circular-import-problem","title":"The Circular Import Problem","text":""},{"location":"08_LEVEL_4_SCALABLE.html#the-scenario","title":"The Scenario","text":"<ol> <li><code>app.py</code> imports <code>db</code> from <code>models.py</code></li> <li><code>models.py</code> imports <code>app</code> from <code>app.py</code> (to use config)</li> <li>CRASH: <code>ImportError: cannot import name...</code></li> </ol>"},{"location":"08_LEVEL_4_SCALABLE.html#the-solution","title":"The Solution","text":"<p>We must decouple the Extension Creation from the App Creation.</p>"},{"location":"08_LEVEL_4_SCALABLE.html#managing-extensions","title":"Managing Extensions","text":"<p>Create a separate file <code>extensions.py</code>. This file instantiates plugins without attaching them to an app.</p> <pre><code># extensions.py\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_migrate import Migrate\nfrom flask_jwt_extended import JWTManager\nfrom flask_marshmallow import Marshmallow\n\n# Unbound extensions\ndb = SQLAlchemy()\nmigrate = Migrate()\njwt = JWTManager()\nma = Marshmallow()\n</code></pre> <p>[!TIP] Magic Box \u2013 Extensions Module: <code>extensions.py</code> centralizes Magic Boxes like <code>db</code>, <code>migrate</code>, <code>jwt</code>, and <code>ma</code>. You import them where needed and call <code>.init_app(app)</code>, without worrying about how they create connections under the hood.</p> <p>Now <code>models.py</code> can import <code>db</code> from <code>extensions.py</code>. <code>extensions.py</code> imports nothing. No cycles!</p>"},{"location":"08_LEVEL_4_SCALABLE.html#the-application-factory-pattern","title":"The Application Factory Pattern","text":"<p>Instead of creating a global <code>app</code> object, we put creation logic in a function <code>create_app()</code>.</p>"},{"location":"08_LEVEL_4_SCALABLE.html#apppy-or-application__init__py","title":"<code>app.py</code> (or <code>application/__init__.py</code>)","text":"<pre><code>from flask import Flask\nfrom extensions import db, migrate, jwt, ma\nfrom routes.user_routes import user_bp\nfrom routes.auth_routes import auth_bp\nfrom app_config import Config\n\ndef create_app(config_class=Config):\n    app = Flask(__name__)\n\n    # 1. Load Configuration\n    app.config.from_object(config_class)\n\n    # 2. Init Extensions\n    db.init_app(app)\n    migrate.init_app(app, db)\n    jwt.init_app(app)\n    ma.init_app(app)\n\n    # 3. Register Blueprints\n    app.register_blueprint(user_bp)\n    app.register_blueprint(auth_bp)\n\n    return app\n</code></pre>"},{"location":"08_LEVEL_4_SCALABLE.html#project-directory-structure","title":"Project Directory Structure","text":"<p>A professional flask project looks like this:</p> <pre><code>project_root/\n\u251c\u2500\u2500 app/                  # Application Package\n\u2502   \u251c\u2500\u2500 __init__.py       # Contains create_app()\n\u2502   \u251c\u2500\u2500 extensions.py     # All extensions (db, jwt, etc)\n\u2502   \u251c\u2500\u2500 models/           # DB Models\n\u2502   \u2502   \u2514\u2500\u2500 user.py\n\u2502   \u251c\u2500\u2500 routes/           # Blueprints\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 user_routes.py\n\u2502   \u251c\u2500\u2500 schemas/          # Marshmallow Schemas\n\u2502   \u2502   \u2514\u2500\u2500 user_schema.py\n\u2502   \u2514\u2500\u2500 services/         # Business Logic\n\u2502       \u2514\u2500\u2500 user_service.py\n\u251c\u2500\u2500 config.py             # Settings (Dev/Prod)\n\u251c\u2500\u2500 wsgi.py               # Entry point for Server\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"08_LEVEL_4_SCALABLE.html#wsgipy-the-entry-point","title":"<code>wsgi.py</code> (The Entry Point)","text":"<p>This is what your server (Gunicorn/uWSGI) runs.</p> <pre><code>from app import create_app\n\napplication = create_app()\n\nif __name__ == \"__main__\":\n    application.run(debug=True)\n</code></pre>"},{"location":"08_LEVEL_4_SCALABLE.html#configuration-management","title":"Configuration Management","text":"<p>Avoid hardcoding. Use classes for config.</p>"},{"location":"08_LEVEL_4_SCALABLE.html#configpy","title":"<code>config.py</code>","text":"<pre><code>import os\n\nclass Config:\n    SECRET_KEY = os.environ.get('SECRET_KEY', 'default-dev-key')\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n\nclass DevConfig(Config):\n    SQLALCHEMY_DATABASE_URI = 'sqlite:///dev.db'\n    DEBUG = True\n\nclass ProdConfig(Config):\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')\n    DEBUG = False\n</code></pre> <p>Then pass it to the factory: <code>create_app(DevConfig)</code></p>"},{"location":"08_LEVEL_4_SCALABLE.html#common-pitfalls-quiz","title":"Common Pitfalls Quiz","text":""},{"location":"08_LEVEL_4_SCALABLE.html#pitfall-1-circular-imports-in-blueprints","title":"Pitfall 1: Circular Imports in Blueprints","text":"<p>Question: Why ImportError?</p> <pre><code># app.py imports blueprint\nfrom routes.user_routes import user_bp\n# routes.py imports app\nfrom app import app  # Circular!\n</code></pre> Click to see answer  **Answer**: Use extensions.py to break the cycle!"},{"location":"08_LEVEL_4_SCALABLE.html#pitfall-2-forgetting-to-register-blueprints","title":"Pitfall 2: Forgetting to Register Blueprints","text":"<p>Question: Why is /users giving 404?</p> <pre><code># Created blueprint but never called app.register_blueprint(user_bp)\n</code></pre> Click to see answer  **Answer**: Must register: `app.register_blueprint(user_bp)`"},{"location":"08_LEVEL_4_SCALABLE.html#practice-problems","title":"Practice Problems","text":""},{"location":"08_LEVEL_4_SCALABLE.html#problem-1-refactor-to-factory","title":"Problem 1: Refactor to Factory","text":"<p>Take your code from Level 3.</p> <ol> <li>Create <code>extensions.py</code>.</li> <li>Move global <code>app</code> var to <code>create_app</code> in <code>app/__init__.py</code>.</li> <li>Create <code>wsgi.py</code>.</li> <li>Run it!</li> </ol> <p>Starter code for app/init.py:</p> <pre><code># app/__init__.py  \nfrom flask import Flask\nfrom extensions import db, jwt\nfrom routes.user_routes import user_bp\n\ndef create_app():\n    app = Flask(__name__)\n    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'\n    app.config['JWT_SECRET_KEY'] = 'your-secret-key'\n\n    # Initialize extensions\n    db.init_app(app)\n    jwt.init_app(app)\n\n    # Note: Is something missing here with the blueprint?\n\n    return app\n</code></pre>"},{"location":"08_LEVEL_4_SCALABLE.html#problem-2-circular-import-fix","title":"Problem 2: Circular Import Fix","text":"<p>Intentionally create a circular import (e.g., import <code>app</code> inside <code>extensions.py</code>). Observe the error. Then fix it by following the pattern above.</p>"},{"location":"08_LEVEL_4_SCALABLE.html#problem-3-environment-config","title":"Problem 3: Environment Config","text":"<p>Create a <code>TestConfig</code> that uses an in-memory database (<code>sqlite:///:memory:</code>). Update <code>create_app</code> to use it when running tests.</p>"},{"location":"08_LEVEL_4_SCALABLE.html#trivia","title":"Trivia","text":""},{"location":"08_LEVEL_4_SCALABLE.html#question-1","title":"Question 1","text":"<p>Why do we use <code>extensions.py</code>?</p> <ul> <li>[ ] To make the code look prettier</li> <li>[x] To avoid circular imports by creating extensions unbound to the app</li> <li>[ ] Because Flask requires it</li> <li>[ ] To store database passwords</li> </ul>"},{"location":"08_LEVEL_4_SCALABLE.html#question-2","title":"Question 2","text":"<p>What does <code>init_app</code> do?</p> <ul> <li>[ ] Deletes the database</li> <li>[ ] Creates a new app</li> <li>[x] Binds an extension instance (like <code>db</code>) to a specific Flask app instance</li> <li>[ ] Installs the library</li> </ul>"},{"location":"08_LEVEL_4_SCALABLE.html#question-3","title":"Question 3","text":"<p>Which file is the entry point for production servers (like Gunicorn)?</p> <ul> <li>[ ] <code>routes.py</code></li> <li>[ ] <code>extensions.py</code></li> <li>[x] <code>wsgi.py</code></li> <li>[ ] <code>config.py</code></li> </ul>"},{"location":"10_TEST_TASK_3.html","title":"Flask Test Task 3 \u2013 Scalable Architecture &amp; Blueprints","text":"<p>Prerequisite: Level 4: Scalable Structure.</p>"},{"location":"10_TEST_TASK_3.html#objective","title":"Objective","text":"<p>Refactor the Library Management API (from Task 2) into a production-ready Structure using the Application Factory Pattern and Blueprints. This task evaluates:</p> <ul> <li>Project Layout &amp; Organization</li> <li>Circular Import Avoidance</li> <li>Blueprint Usage</li> <li>Configuration Management</li> </ul>"},{"location":"10_TEST_TASK_3.html#problem-statement","title":"Problem Statement","text":"<p>Take the code from Task 2 and refactor it. The functionality remains the same (Authors &amp; Books), but the structure must change drastically.</p>"},{"location":"10_TEST_TASK_3.html#required-structure","title":"Required Structure","text":"<pre><code>library_project/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 __init__.py         # create_app() function\n\u2502   \u251c\u2500\u2500 extensions.py       # db, migrate initialization\n\u2502   \u251c\u2500\u2500 models/             # Separate file for models (or package)\n\u2502   \u2502   \u251c\u2500\u2500 author.py\n\u2502   \u2502   \u2514\u2500\u2500 book.py\n\u2502   \u251c\u2500\u2500 routes/             # Blueprints\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 author_routes.py\n\u2502   \u2502   \u2514\u2500\u2500 book_routes.py\n\u2502   \u251c\u2500\u2500 services/           # Service Layer\n\u2502   \u2502   \u251c\u2500\u2500 author_service.py\n\u2502   \u2502   \u2514\u2500\u2500 book_service.py\n\u251c\u2500\u2500 config.py               # Config classes (Dev, Test)\n\u251c\u2500\u2500 wsgi.py                 # Entry point\n\u2514\u2500\u2500 requirements.txt\n</code></pre>"},{"location":"10_TEST_TASK_3.html#technical-constraints","title":"Technical Constraints","text":"<ol> <li>Application Factory: <code>app/__init__.py</code> must contain <code>def create_app(config_class):</code>.</li> <li>Extensions: <code>db</code> and <code>migrate</code> must be created in <code>extensions.py</code> (not in <code>__init__.py</code>).</li> <li>Blueprints:<ul> <li><code>author_bp</code> prefix: <code>/api/v1/authors</code></li> <li><code>book_bp</code> prefix: <code>/api/v1/books</code></li> </ul> </li> <li>No Circular Imports: Models must import <code>db</code> from <code>extensions.py</code>.</li> <li>Config: <code>config.py</code> should have a <code>DevConfig</code> and <code>TestConfig</code>.</li> </ol>"},{"location":"10_TEST_TASK_3.html#bonus-challenge-optional","title":"Bonus Challenge (Optional)","text":"<p>Add a custom CLI command to seed the database with initial data.</p> <ul> <li>Command: <code>flask seed-db</code></li> <li>Action: Adds 2 authors and 5 books.</li> </ul>"},{"location":"CURL_GUIDE.html","title":"cURL Command Guide for API Testing","text":""},{"location":"CURL_GUIDE.html#overview","title":"Overview","text":"<p>cURL (Client URL) is a command-line tool for making HTTP requests. It's the most reliable way to test REST APIs and is available on all operating systems. This guide will teach you how to use cURL to test your Flask APIs.</p>"},{"location":"CURL_GUIDE.html#table-of-contents","title":"Table of Contents","text":"<ol> <li>What is cURL?</li> <li>Installation</li> <li>Basic Requests</li> <li>Headers and Content Types</li> <li>Authentication</li> <li>File Uploads</li> <li>Advanced Usage</li> <li>Examples by Flask Level</li> <li>Troubleshooting</li> </ol>"},{"location":"CURL_GUIDE.html#what-is-curl","title":"What is cURL?","text":"<p>cURL is a command-line tool that allows you to transfer data to or from a server using various protocols (HTTP, HTTPS, FTP, etc.). For API testing, we primarily use it for HTTP/HTTPS requests.</p> <p>Why use cURL?</p> <ul> <li>Available on all platforms</li> <li>No GUI needed - works in terminal</li> <li>Scriptable and automatable</li> <li>Shows raw HTTP requests/responses</li> <li>Industry standard for API testing</li> </ul>"},{"location":"CURL_GUIDE.html#installation","title":"Installation","text":""},{"location":"CURL_GUIDE.html#linux","title":"Linux","text":"<p>Most Linux distributions come with cURL pre-installed. If not:</p> <pre><code># Ubuntu/Debian\nsudo apt install curl\n\n# CentOS/RHEL\nsudo yum install curl\n\n# Verify installation\ncurl --version\n</code></pre>"},{"location":"CURL_GUIDE.html#macos","title":"macOS","text":"<p>cURL comes pre-installed. Verify:</p> <pre><code>curl --version\n</code></pre>"},{"location":"CURL_GUIDE.html#windows","title":"Windows","text":""},{"location":"CURL_GUIDE.html#option-1-windows-1011-built-in","title":"Option 1: Windows 10/11 (Built-in)","text":"<ul> <li>cURL is included in Windows 10 version 1803 and later</li> <li>Open PowerShell or Command Prompt and type: <code>curl --version</code></li> </ul>"},{"location":"CURL_GUIDE.html#option-2-download","title":"Option 2: Download","text":"<ul> <li>Download from curl.se/windows/</li> <li>Or use Git Bash (includes cURL)</li> </ul>"},{"location":"CURL_GUIDE.html#option-3-using-chocolatey","title":"Option 3: Using Chocolatey","text":"<pre><code>choco install curl\n</code></pre>"},{"location":"CURL_GUIDE.html#basic-requests","title":"Basic Requests","text":""},{"location":"CURL_GUIDE.html#get-request","title":"GET Request","text":"<p>The simplest request - fetching data:</p> <pre><code># Basic GET request\ncurl http://127.0.0.1:5000/api/tasks/\n\n# With verbose output (see headers)\ncurl -v http://127.0.0.1:5000/api/tasks/\n\n# Pretty print JSON response (requires jq)\ncurl http://127.0.0.1:5000/api/tasks/ | jq\n\n# Save response to file\ncurl http://127.0.0.1:5000/api/tasks/ -o response.json\n\n# Follow redirects\ncurl -L http://127.0.0.1:5000/api/tasks/\n</code></pre>"},{"location":"CURL_GUIDE.html#post-request","title":"POST Request","text":"<p>Creating new resources:</p> <pre><code># Basic POST with JSON data\ncurl -X POST http://127.0.0.1:5000/api/tasks/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Learn Flask\", \"desc\": \"Complete the learning guide\", \"completed\": false}'\n\n# POST with data from file\ncurl -X POST http://127.0.0.1:5000/api/tasks/ \\\n  -H \"Content-Type: application/json\" \\\n  -d @data.json\n\n# POST with form data\ncurl -X POST http://127.0.0.1:5000/api/tasks/ \\\n  -d \"title=Learn Flask\" \\\n  -d \"desc=Complete the learning guide\" \\\n  -d \"completed=false\"\n</code></pre> <p>[!IMPORTANT] Windows PowerShell Users: The syntax above uses Unix/Linux/Mac conventions. See the Windows PowerShell section below for correct syntax on Windows.</p>"},{"location":"CURL_GUIDE.html#put-request","title":"PUT Request","text":"<p>Full update of a resource:</p> <pre><code>curl -X PUT http://127.0.0.1:5000/api/tasks/1/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Updated Task\", \"desc\": \"Updated description\", \"completed\": true}'\n</code></pre>"},{"location":"CURL_GUIDE.html#patch-request","title":"PATCH Request","text":"<p>Partial update of a resource:</p> <pre><code>curl -X PATCH http://127.0.0.1:5000/api/tasks/1/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"completed\": true}'\n</code></pre>"},{"location":"CURL_GUIDE.html#delete-request","title":"DELETE Request","text":"<p>Deleting a resource:</p> <pre><code>curl -X DELETE http://127.0.0.1:5000/api/tasks/1/\n</code></pre>"},{"location":"CURL_GUIDE.html#windows-powershell-syntax","title":"Windows PowerShell Syntax","text":"<p>[!WARNING] PowerShell uses different syntax than Unix shells! Copy-pasting Unix examples will fail.</p>"},{"location":"CURL_GUIDE.html#key-differences","title":"Key Differences","text":"Feature Unix/Linux/Mac Windows PowerShell Line continuation <code>\\</code> backslash <code>`</code> backtick JSON quotes Single quotes <code>'</code> Escaped double quotes Variables <code>$VAR</code> <code>$env:VAR</code>"},{"location":"CURL_GUIDE.html#get-request-same-on-windows","title":"GET Request (Same on Windows)","text":"<pre><code># GET works the same\ncurl http://127.0.0.1:5000/api/tasks/\n</code></pre>"},{"location":"CURL_GUIDE.html#post-request-with-json","title":"POST Request with JSON","text":""},{"location":"CURL_GUIDE.html#option-1-single-line-recommended-for-beginners","title":"Option 1: Single Line (Recommended for Beginners)","text":"<pre><code>curl -X POST http://127.0.0.1:5000/api/tasks/ -H \"Content-Type: application/json\" -d \"{`\"title`\":`\"Learn Flask`\",`\"completed`\":false}\"\n</code></pre>"},{"location":"CURL_GUIDE.html#option-2-multi-line-with-backtick","title":"Option 2: Multi-line with Backtick","text":"<pre><code>curl -X POST http://127.0.0.1:5000/api/tasks/ `\n  -H \"Content-Type: application/json\" `\n  -d \"{`\"title`\":`\"Learn Flask`\",`\"completed`\":false}\"\n</code></pre>"},{"location":"CURL_GUIDE.html#option-3-using-here-string-cleanest","title":"Option 3: Using Here-String (Cleanest)","text":"<pre><code>$json = @\"\n{\n  \"title\": \"Learn Flask\",\n  \"desc\": \"Complete the guide\",\n  \"completed\": false\n}\n\"@\n\ncurl -X POST http://127.0.0.1:5000/api/tasks/ `\n  -H \"Content-Type: application/json\" `\n  -d $json\n</code></pre>"},{"location":"CURL_GUIDE.html#put-request_1","title":"PUT Request","text":"<pre><code>curl -X PUT http://127.0.0.1:5000/api/tasks/1/ `\n  -H \"Content-Type: application/json\" `\n  -d \"{`\"title`\":`\"Updated Task`\",`\"completed`\":true}\"\n</code></pre>"},{"location":"CURL_GUIDE.html#patch-request_1","title":"PATCH Request","text":"<pre><code>curl -X PATCH http://127.0.0.1:5000/api/tasks/1/ `\n  -H \"Content-Type: application/json\" `\n  -d \"{`\"completed`\":true}\"\n</code></pre>"},{"location":"CURL_GUIDE.html#delete-request-same-on-windows","title":"DELETE Request (Same on Windows)","text":"<pre><code>curl -X DELETE http://127.0.0.1:5000/api/tasks/1/\n</code></pre>"},{"location":"CURL_GUIDE.html#jwt-authentication","title":"JWT Authentication","text":"<pre><code># Get token\n$response = curl -X POST http://127.0.0.1:5000/auth/login `\n  -H \"Content-Type: application/json\" `\n  -d \"{`\"email`\":`\"user@example.com`\",`\"password`\":`\"pass123`\"}\" | ConvertFrom-Json\n\n$token = $response.access_token\n\n# Use token\ncurl -H \"Authorization: Bearer $token\" http://127.0.0.1:5000/api/tasks/\n</code></pre> <p>[!TIP] Quick Tip: Use the here-string method (<code>@\" ... \"@</code>) for complex JSON in PowerShell. It's much cleaner than escaping quotes!</p>"},{"location":"CURL_GUIDE.html#headers-and-content-types","title":"Headers and Content Types","text":""},{"location":"CURL_GUIDE.html#setting-headers","title":"Setting Headers","text":"<pre><code># Single header\ncurl -H \"Content-Type: application/json\" http://127.0.0.1:5000/api/tasks/\n\n# Multiple headers\ncurl -H \"Content-Type: application/json\" \\\n     -H \"Accept: application/json\" \\\n     http://127.0.0.1:5000/api/tasks/\n\n# Custom header\ncurl -H \"X-Custom-Header: my-value\" http://127.0.0.1:5000/api/tasks/\n</code></pre>"},{"location":"CURL_GUIDE.html#common-headers","title":"Common Headers","text":"<pre><code># JSON content\ncurl -H \"Content-Type: application/json\" ...\n\n# XML content\ncurl -H \"Content-Type: application/xml\" ...\n\n# Accept only JSON response\ncurl -H \"Accept: application/json\" ...\n\n# User agent\ncurl -H \"User-Agent: MyApp/1.0\" ...\n</code></pre>"},{"location":"CURL_GUIDE.html#authentication","title":"Authentication","text":""},{"location":"CURL_GUIDE.html#basic-authentication","title":"Basic Authentication","text":"<pre><code># Basic auth (username:password)\ncurl -u username:password http://127.0.0.1:5000/api/tasks/\n\n# Or with header\ncurl -H \"Authorization: Basic $(echo -n 'username:password' | base64)\" \\\n  http://127.0.0.1:5000/api/tasks/\n</code></pre>"},{"location":"CURL_GUIDE.html#bearer-token-jwt","title":"Bearer Token (JWT)","text":"<pre><code># With Bearer token\ncurl -H \"Authorization: Bearer your_jwt_token_here\" \\\n  http://127.0.0.1:5000/api/tasks/\n\n# Store token in variable (bash)\nTOKEN=\"your_jwt_token_here\"\ncurl -H \"Authorization: Bearer $TOKEN\" \\\n  http://127.0.0.1:5000/api/tasks/\n</code></pre>"},{"location":"CURL_GUIDE.html#getting-jwt-token","title":"Getting JWT Token","text":"<pre><code># Login to get token (example: your Flask /auth/login endpoint)\ncurl -X POST http://127.0.0.1:5000/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"admin@example.com\", \"password\": \"password123\"}' \\\n  | jq -r '.access_token'\n\n# Save token to variable\nTOKEN=$(curl -s -X POST http://127.0.0.1:5000/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"admin@example.com\", \"password\": \"password123\"}' \\\n  | jq -r '.access_token')\n\n# Use token in subsequent requests\ncurl -H \"Authorization: Bearer $TOKEN\" \\\n  http://127.0.0.1:5000/api/tasks/\n</code></pre>"},{"location":"CURL_GUIDE.html#file-uploads","title":"File Uploads","text":""},{"location":"CURL_GUIDE.html#upload-single-file","title":"Upload Single File","text":"<pre><code># Upload file\ncurl -X POST http://127.0.0.1:5000/api/tasks/1/upload/ \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -F \"file=@/path/to/file.pdf\"\n\n# Upload with additional data\ncurl -X POST http://127.0.0.1:5000/api/tasks/1/upload/ \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -F \"file=@/path/to/file.pdf\" \\\n  -F \"description=Task attachment\"\n</code></pre>"},{"location":"CURL_GUIDE.html#upload-multiple-files","title":"Upload Multiple Files","text":"<pre><code>curl -X POST http://127.0.0.1:5000/api/tasks/1/upload/ \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -F \"files=@/path/to/file1.pdf\" \\\n  -F \"files=@/path/to/file2.jpg\"\n</code></pre>"},{"location":"CURL_GUIDE.html#advanced-usage","title":"Advanced Usage","text":""},{"location":"CURL_GUIDE.html#verbose-mode","title":"Verbose Mode","text":"<p>See full request/response details:</p> <pre><code>curl -v http://127.0.0.1:5000/api/tasks/\n\n# Shows:\n# - Request headers\n# - Response headers\n# - SSL handshake (if HTTPS)\n# - Connection details\n</code></pre>"},{"location":"CURL_GUIDE.html#silent-mode","title":"Silent Mode","text":"<p>Suppress progress meter:</p> <pre><code>curl -s http://127.0.0.1:5000/api/tasks/\n</code></pre>"},{"location":"CURL_GUIDE.html#show-only-response-headers","title":"Show Only Response Headers","text":"<pre><code>curl -I http://127.0.0.1:5000/api/tasks/\n\n# Or\ncurl -D - http://127.0.0.1:5000/api/tasks/\n</code></pre>"},{"location":"CURL_GUIDE.html#follow-redirects","title":"Follow Redirects","text":"<pre><code>curl -L http://127.0.0.1:5000/api/tasks/\n</code></pre>"},{"location":"CURL_GUIDE.html#timeout","title":"Timeout","text":"<pre><code># Set timeout to 10 seconds\ncurl --max-time 10 http://127.0.0.1:5000/api/tasks/\n\n# Connection timeout\ncurl --connect-timeout 5 http://127.0.0.1:5000/api/tasks/\n</code></pre>"},{"location":"CURL_GUIDE.html#save-response-headers","title":"Save Response Headers","text":"<pre><code># Save headers to file\ncurl -D headers.txt http://127.0.0.1:5000/api/tasks/\n\n# Save both headers and body\ncurl -D headers.txt -o response.json http://127.0.0.1:5000/api/tasks/\n</code></pre>"},{"location":"CURL_GUIDE.html#pretty-print-json","title":"Pretty Print JSON","text":"<pre><code># Using jq (install: sudo apt install jq)\ncurl http://127.0.0.1:5000/api/tasks/ | jq\n\n# Using python\ncurl http://127.0.0.1:5000/api/tasks/ | python -m json.tool\n</code></pre>"},{"location":"CURL_GUIDE.html#examples-by-flask-level","title":"Examples by Flask Level","text":""},{"location":"CURL_GUIDE.html#level-1-basic-crud-operations","title":"Level 1: Basic CRUD Operations","text":"<pre><code># GET - List all tasks\ncurl http://127.0.0.1:5000/api/tasks/\n\n# GET - Retrieve single task\ncurl http://127.0.0.1:5000/api/tasks/1/\n\n# POST - Create new task\ncurl -X POST http://127.0.0.1:5000/api/tasks/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"Learn Flask\",\n    \"desc\": \"Complete Level 1\",\n    \"completed\": false\n  }'\n\n# PUT - Update task\ncurl -X PUT http://127.0.0.1:5000/api/tasks/1/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"Learn Flask - Updated\",\n    \"desc\": \"Completed Level 1\",\n    \"completed\": true\n  }'\n\n# PATCH - Partial update\ncurl -X PATCH http://127.0.0.1:5000/api/tasks/1/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"completed\": true}'\n\n# DELETE - Delete task\ncurl -X DELETE http://127.0.0.1:5000/api/tasks/1/\n</code></pre>"},{"location":"CURL_GUIDE.html#level-2-authenticated-requests","title":"Level 2: Authenticated Requests","text":"<pre><code># Step 1: Get JWT token from your Flask auth endpoint\nTOKEN=$(curl -s -X POST http://127.0.0.1:5000/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"admin@example.com\", \"password\": \"password123\"}' \\\n  | python -c \"import sys, json; print(json.load(sys.stdin)['access_token'])\")\n\n# Step 2: Use token in requests\ncurl -H \"Authorization: Bearer $TOKEN\" \\\n  http://127.0.0.1:5000/api/tasks/\n\n# Create task with authentication\ncurl -X POST http://127.0.0.1:5000/api/tasks/ \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -d '{\n    \"title\": \"Private Task\",\n    \"desc\": \"Only visible to authenticated users\",\n    \"completed\": false\n  }'\n</code></pre>"},{"location":"CURL_GUIDE.html#level-3-complex-nested-data","title":"Level 3: Complex Nested Data","text":"<pre><code># POST with nested relationships (example blog API)\ncurl -X POST http://127.0.0.1:5000/api/posts/ \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -d '{\n    \"title\": \"My First Post\",\n    \"content\": \"This is the content\",\n    \"author_id\": 1,\n    \"tags\": [\"flask\", \"api\"],\n    \"comments\": [\n      {\n        \"content\": \"Great post!\",\n        \"author_name\": \"Bob\"\n      }\n    ]\n  }'\n\n# GET with nested data\ncurl -H \"Authorization: Bearer $TOKEN\" \\\n  http://127.0.0.1:5000/api/posts/1/\n</code></pre>"},{"location":"CURL_GUIDE.html#level-4-file-uploads-and-versioned-apis","title":"Level 4: File Uploads and Versioned APIs","text":"<pre><code># File upload\ncurl -X POST http://127.0.0.1:5000/api/v1/tasks/1/attachments/ \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -F \"file=@/path/to/document.pdf\" \\\n  -F \"description=Task attachment\"\n\n# Versioned API (v1)\ncurl http://127.0.0.1:5000/api/v1/tasks/\n\n# Versioned API (v2)\ncurl http://127.0.0.1:5000/api/v2/tasks/\n\n# With version header\ncurl -H \"Accept: application/json; version=2\" \\\n  http://127.0.0.1:5000/api/tasks/\n</code></pre>"},{"location":"CURL_GUIDE.html#common-curl-flags-reference","title":"Common cURL Flags Reference","text":"Flag Description <code>-X METHOD</code> HTTP method (GET, POST, PUT, DELETE, etc.) <code>-H \"Header: value\"</code> Add header <code>-d \"data\"</code> Send data in request body <code>-F \"name=value\"</code> Form data (for file uploads) <code>-u user:pass</code> Basic authentication <code>-v</code> Verbose output <code>-s</code> Silent mode (no progress) <code>-i</code> Include response headers <code>-I</code> Head request (headers only) <code>-L</code> Follow redirects <code>-o file</code> Save output to file <code>-O</code> Save with remote filename <code>-D file</code> Save headers to file <code>--max-time SEC</code> Maximum time for request <code>--connect-timeout SEC</code> Connection timeout <code>-k</code> Allow insecure SSL connections <code>-c file</code> Save cookies to file <code>-b file</code> Load cookies from file"},{"location":"CURL_GUIDE.html#converting-postman-to-curl","title":"Converting Postman to cURL","text":""},{"location":"CURL_GUIDE.html#in-postman","title":"In Postman","text":"<ol> <li>Open your request in Postman</li> <li>Click \"Code\" button (bottom left)</li> <li>Select \"cURL\" from dropdown</li> <li>Copy the generated cURL command</li> </ol>"},{"location":"CURL_GUIDE.html#manual-conversion-tips","title":"Manual Conversion Tips","text":"<ul> <li>Headers: Each header becomes <code>-H \"Header: value\"</code></li> <li>Body: JSON becomes <code>-d '{\"key\": \"value\"}'</code></li> <li>Auth: Bearer token becomes <code>-H \"Authorization: Bearer token\"</code></li> <li>Files: Use <code>-F \"file=@path/to/file\"</code></li> </ul>"},{"location":"CURL_GUIDE.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"CURL_GUIDE.html#common-issues","title":"Common Issues","text":""},{"location":"CURL_GUIDE.html#1-connection-refused","title":"1. Connection Refused","text":"<pre><code># Check if server is running\ncurl http://127.0.0.1:5000/api/tasks/\n\n# Error: Connection refused\n# Solution: Start your Flask server\n# Example:\n# python app.py\n# or:\n# flask run\n</code></pre>"},{"location":"CURL_GUIDE.html#2-404-not-found","title":"2. 404 Not Found","text":"<pre><code># Check URL is correct\ncurl -v http://127.0.0.1:5000/api/tasks/\n\n# Verify route in Flask:\n# - Check your @app.route or @blueprint.route path\n# - Ensure you are using the correct HTTP method (GET/POST/...)\n</code></pre>"},{"location":"CURL_GUIDE.html#3-401-unauthorized","title":"3. 401 Unauthorized","text":"<pre><code># Missing or invalid token\n# Solution: Get new token from your Flask auth endpoint\nTOKEN=$(curl -s -X POST http://127.0.0.1:5000/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"user@example.com\", \"password\": \"pass\"}' \\\n  | jq -r '.access_token')\n</code></pre>"},{"location":"CURL_GUIDE.html#4-400-bad-request","title":"4. 400 Bad Request","text":"<pre><code># Check JSON syntax\ncurl -X POST http://127.0.0.1:5000/api/tasks/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Test\"}'  # Valid JSON\n\n# Use verbose mode to see error details\ncurl -v -X POST http://127.0.0.1:5000/api/tasks/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Test\"}'\n</code></pre>"},{"location":"CURL_GUIDE.html#5-ssl-certificate-errors","title":"5. SSL Certificate Errors","text":"<pre><code># For development (not recommended for production)\ncurl -k https://api.example.com/\n\n# Or specify certificate\ncurl --cacert /path/to/cert.pem https://api.example.com/\n</code></pre>"},{"location":"CURL_GUIDE.html#debugging-tips","title":"Debugging Tips","text":"<ol> <li>Use verbose mode: <code>curl -v</code> shows full request/response</li> <li>Check response headers: <code>curl -I</code> shows only headers</li> <li>Save responses: <code>curl -o response.json</code> to inspect later</li> <li>Test with simple request first: Start with GET before POST</li> <li>Validate JSON: Use <code>jq</code> or <code>python -m json.tool</code></li> </ol>"},{"location":"CURL_GUIDE.html#practice-exercises","title":"Practice Exercises","text":""},{"location":"CURL_GUIDE.html#exercise-1-basic-crud","title":"Exercise 1: Basic CRUD","text":"<pre><code># 1. List all tasks\ncurl http://127.0.0.1:5000/api/tasks/\n\n# 2. Create a task\ncurl -X POST http://127.0.0.1:5000/api/tasks/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Exercise Task\", \"completed\": false}'\n\n# 3. Get the created task (use ID from step 2)\ncurl http://127.0.0.1:5000/api/tasks/1/\n\n# 4. Update the task\ncurl -X PATCH http://127.0.0.1:5000/api/tasks/1/ \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"completed\": true}'\n\n# 5. Delete the task\ncurl -X DELETE http://127.0.0.1:5000/api/tasks/1/\n</code></pre>"},{"location":"CURL_GUIDE.html#exercise-2-authentication-flow","title":"Exercise 2: Authentication Flow","text":"<pre><code># 1. Register a user\ncurl -X POST http://127.0.0.1:5000/auth/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"username\": \"testuser\", \"password\": \"testpass123\", \"email\": \"test@example.com\"}'\n\n# 2. Get JWT token\nTOKEN=$(curl -s -X POST http://127.0.0.1:5000/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"testuser@example.com\", \"password\": \"testpass123\"}' \\\n  | jq -r '.access_token')\n\n# 3. Use token to access protected endpoint\ncurl -H \"Authorization: Bearer $TOKEN\" \\\n  http://127.0.0.1:5000/api/tasks/\n</code></pre>"},{"location":"CURL_GUIDE.html#next-steps","title":"Next Steps","text":"<p>Now that you know cURL basics:</p> <ol> <li>Practice with your Level 1 API</li> <li>Use cURL to test all endpoints</li> <li>Create a script with common requests</li> <li>Refer back to this guide as you progress through levels</li> </ol> <p>For more information:</p> <ul> <li>cURL Official Documentation</li> <li>HTTPie - Alternative to cURL with better UX</li> <li>Postman - GUI alternative</li> </ul> <p>Ready to test your APIs? Use these cURL commands as you work through each level of the Flask Learning Guide!</p>"},{"location":"PATTERN_CHEATSHEET.html","title":"Flask Pattern Cheatsheet","text":"<p>Quick reference for common Flask patterns. Copy-paste these as starting points.</p>"},{"location":"PATTERN_CHEATSHEET.html#table-of-contents","title":"Table of Contents","text":"<ol> <li>Service Layer Pattern</li> <li>Extensions Pattern</li> <li>Model Relationships</li> <li>Blueprint Registration</li> <li>Migration Workflow</li> <li>Error Handling</li> <li>Common Imports</li> </ol>"},{"location":"PATTERN_CHEATSHEET.html#service-layer-pattern","title":"Service Layer Pattern","text":"<p>You can use either class-based or function-based services. Both are correct!</p>"},{"location":"PATTERN_CHEATSHEET.html#option-1-class-based-industry-standard","title":"Option 1: Class-Based (Industry Standard)","text":"<pre><code># services/user_service.py\nfrom models import User\nfrom extensions import db\n\nclass UserService:\n    @staticmethod\n    def create_user(username, email, password_hash):\n        \"\"\"Create a new user.\"\"\"\n        # Check if exists\n        if User.query.filter_by(email=email).first():\n            return None, \"Email already exists\"\n\n        # Create and save\n        user = User(username=username, email=email, password_hash=password_hash)\n        db.session.add(user)\n        db.session.commit()\n\n        return user, None\n\n    @staticmethod\n    def get_user_by_id(user_id):\n        \"\"\"Get user by ID.\"\"\"\n        user = User.query.get(user_id)\n        if not user:\n            return None, \"User not found\"\n        return user, None\n\n    @staticmethod\n    def get_all_users():\n        \"\"\"Get all users.\"\"\"\n        return User.query.all()\n</code></pre> <p>Using class-based service in routes:</p> <pre><code># app.py\nfrom flask import request, jsonify\nfrom services.user_service import UserService\n\n@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n\n    # Call service method\n    user, error = UserService.create_user(\n        username=data['username'],\n        email=data['email'],\n        password_hash=data['password']\n    )\n\n    if error:\n        return jsonify({\"error\": error}), 400\n\n    return jsonify({\"id\": user.id, \"username\": user.username}), 201\n\n@app.route('/users', methods=['GET'])\ndef get_users():\n    users = UserService.get_all_users()\n    return jsonify({\"users\": [{\"id\": u.id, \"username\": u.username} for u in users]}), 200\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#option-2-function-based-simple-alternative","title":"Option 2: Function-Based (Simple Alternative)","text":"<pre><code># services/user_functions.py\nfrom models import User\nfrom extensions import db\n\ndef create_user(username, email, password_hash):\n    \"\"\"Create a new user.\"\"\"\n    # Check if exists\n    if User.query.filter_by(email=email).first():\n        return None, \"Email already exists\"\n\n    # Create and save\n    user = User(username=username, email=email, password_hash=password_hash)\n    db.session.add(user)\n    db.session.commit()\n\n    return user, None\n\ndef get_user_by_id(user_id):\n    \"\"\"Get user by ID.\"\"\"\n    user = User.query.get(user_id)\n    if not user:\n        return None, \"User not found\"\n    return user, None\n\ndef get_all_users():\n    \"\"\"Get all users.\"\"\"\n    return User.query.all()\n</code></pre> <p>Using function-based service in routes:</p> <pre><code># app.py\nfrom flask import request, jsonify\nfrom services.user_functions import create_user, get_user_by_id, get_all_users\n\n@app.route('/users', methods=['POST'])\ndef create_user_endpoint():\n    data = request.get_json()\n\n    # Call service function\n    user, error = create_user(\n        username=data['username'],\n        email=data['email'],\n        password_hash=data['password']\n    )\n\n    if error:\n        return jsonify({\"error\": error}), 400\n\n    return jsonify({\"id\": user.id, \"username\": user.username}), 201\n\n@app.route('/users', methods=['GET'])\ndef get_users_endpoint():\n    users = get_all_users()\n    return jsonify({\"users\": [{\"id\": u.id, \"username\": u.username} for u in users]}), 200\n</code></pre> <p>Which to choose?</p> <ul> <li>Class-based: Better for larger projects, groups related functions</li> <li>Function-based: Simpler, less to learn, works perfectly fine</li> <li>Use whichever you're comfortable with!</li> </ul>"},{"location":"PATTERN_CHEATSHEET.html#extensions-pattern","title":"Extensions Pattern","text":""},{"location":"PATTERN_CHEATSHEET.html#extensionspy","title":"extensions.py","text":"<pre><code># extensions.py\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_migrate import Migrate\nfrom flask_jwt_extended import JWTManager\nfrom flask_marshmallow import Marshmallow\nfrom flask_bcrypt import Bcrypt\n\n# Create unbound extensions\ndb = SQLAlchemy()\nmigrate = Migrate()\njwt = JWTManager()\nma = Marshmallow()\nbcrypt = Bcrypt()\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#initialize-in-app-factory","title":"Initialize in App Factory","text":"<pre><code># app.py or app/__init__.py\nfrom flask import Flask\nfrom extensions import db, migrate, jwt, ma, bcrypt\n\ndef create_app():\n    app = Flask(__name__)\n\n    # Config\n    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'\n    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\n    app.config['JWT_SECRET_KEY'] = 'your-secret-key'\n\n    # Initialize extensions\n    db.init_app(app)\n    migrate.init_app(app, db)\n    jwt.init_app(app)\n    ma.init_app(app)\n    bcrypt.init_app(app)\n\n    # Import models (AFTER init, INSIDE function)\n    from models import User\n\n    return app\n\nif __name__ == '__main__':\n    app = create_app()\n    app.run(debug=True)\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#model-relationships","title":"Model Relationships","text":""},{"location":"PATTERN_CHEATSHEET.html#one-to-many-author-books","title":"One-to-Many (Author \u2192 Books)","text":"<pre><code># models.py\nfrom extensions import db\n\nclass Author(db.Model):\n    __tablename__ = 'authors'\n\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(100), unique=True, nullable=False)\n    bio = db.Column(db.String(500))\n\n    # One-to-Many relationship\n    books = db.relationship('Book', backref='author', cascade='all, delete-orphan')\n\nclass Book(db.Model):\n    __tablename__ = 'books'\n\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(200), nullable=False)\n    price = db.Column(db.Float, nullable=False)\n\n    # Foreign Key\n    author_id = db.Column(db.Integer, db.ForeignKey('authors.id'), nullable=False)\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#manual-serialization-no-schemas-needed","title":"Manual Serialization (No Schemas Needed)","text":"<pre><code># In route\n@app.route('/authors/&lt;int:id&gt;', methods=['GET'])\ndef get_author(id):\n    author = Author.query.get_or_404(id)\n\n    return jsonify({\n        \"id\": author.id,\n        \"name\": author.name,\n        \"bio\": author.bio,\n        \"books\": [\n            {\"id\": b.id, \"title\": b.title, \"price\": b.price}\n            for b in author.books\n        ]\n    }), 200\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#blueprint-registration","title":"Blueprint Registration","text":""},{"location":"PATTERN_CHEATSHEET.html#creating-a-blueprint","title":"Creating a Blueprint","text":"<pre><code># routes/user_routes.py\nfrom flask import Blueprint, jsonify, request\n\nuser_bp = Blueprint('users', __name__, url_prefix='/users')\n\n@user_bp.route('/', methods=['GET'])\ndef get_users():\n    return jsonify({\"users\": []})\n\n@user_bp.route('/&lt;int:id&gt;', methods=['GET'])\ndef get_user(id):\n    return jsonify({\"id\": id})\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#registering-in-app","title":"Registering in App","text":"<pre><code># app.py or app/__init__.py\nfrom flask import Flask\nfrom routes.user_routes import user_bp\nfrom routes.auth_routes import auth_bp\n\ndef create_app():\n    app = Flask(__name__)\n\n    # Register blueprints\n    app.register_blueprint(user_bp)\n    app.register_blueprint(auth_bp)\n\n    return app\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#migration-workflow","title":"Migration Workflow","text":""},{"location":"PATTERN_CHEATSHEET.html#initial-setup-once-per-project","title":"Initial Setup (ONCE per project)","text":"<pre><code># Initialize migrations folder\nflask db init\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#when-you-change-models","title":"When You Change Models","text":"<pre><code># 1. Modify your model in models.py\n# 2. Generate migration\nflask db migrate -m \"Add phone number to users\"\n\n# 3. Apply migration\nflask db upgrade\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#common-commands","title":"Common Commands","text":"<pre><code># Check current migration version\nflask db current\n\n# Downgrade one version (rollback)\nflask db downgrade\n\n# View migration history\nflask db history\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#troubleshooting","title":"Troubleshooting","text":"<pre><code># \"No changes detected\" - Check:\n# 1. Did you import model in app.py?\n# 2. Did you save models.py?\n\n# Nuclear option (development only!)\nrm -rf migrations/\nrm app.db\nflask db init\nflask db migrate -m \"Initial migration\"\nflask db upgrade\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#error-handling","title":"Error Handling","text":""},{"location":"PATTERN_CHEATSHEET.html#custom-exception","title":"Custom Exception","text":"<pre><code># errors.py\nclass AppError(Exception):\n    def __init__(self, message, status_code=400):\n        super().__init__(message)\n        self.message = message\n        self.status_code = status_code\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#global-error-handlers","title":"Global Error Handlers","text":"<pre><code># app.py\nfrom errors import AppError\n\ndef create_app():\n    app = Flask(__name__)\n\n    @app.errorhandler(AppError)\n    def handle_app_error(e):\n        return jsonify({\"error\": e.message}), e.status_code\n\n    @app.errorhandler(404)\n    def handle_404(e):\n        return jsonify({\"error\": \"Resource not found\"}), 404\n\n    @app.errorhandler(500)\n    def handle_500(e):\n        # Log error internally\n        app.logger.error(f\"Server error: {e}\")\n        # Return generic message to user\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n    return app\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#using-in-services","title":"Using in Services","text":"<pre><code>from errors import AppError\n\nclass UserService:\n    @staticmethod\n    def get_user_by_id(user_id):\n        user = User.query.get(user_id)\n        if not user:\n            raise AppError(\"User not found\", 404)\n        return user\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#common-imports","title":"Common Imports","text":""},{"location":"PATTERN_CHEATSHEET.html#basic-route-file","title":"Basic Route File","text":"<pre><code>from flask import request, jsonify, abort\nfrom services.user_service import UserService\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#model-file","title":"Model File","text":"<pre><code>from extensions import db\nfrom datetime import datetime\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#service-file","title":"Service File","text":"<pre><code>from models import User\nfrom extensions import db\nfrom errors import AppError  # If using custom errors\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#app-factory-apppy","title":"App Factory (app.py)","text":"<pre><code>from flask import Flask\nfrom extensions import db, migrate, jwt, ma, bcrypt\nfrom routes.user_routes import user_bp\nfrom routes.auth_routes import auth_bp\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#authentication-service","title":"Authentication Service","text":"<pre><code>from models import User\nfrom extensions import db, bcrypt\nfrom flask_jwt_extended import create_access_token\nfrom errors import AppError\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#quick-sqlalchemy-crud","title":"Quick SQLAlchemy CRUD","text":""},{"location":"PATTERN_CHEATSHEET.html#create","title":"Create","text":"<pre><code>new_user = User(username=\"alice\", email=\"alice@example.com\")\ndb.session.add(new_user)\ndb.session.commit()\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#read","title":"Read","text":"<pre><code># Get by ID\nuser = User.query.get(1)\n\n# Get first match\nuser = User.query.filter_by(email=\"alice@example.com\").first()\n\n# Get all\nusers = User.query.all()\n\n# Get with error if not found\nuser = User.query.get_or_404(1)\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#update","title":"Update","text":"<pre><code>user = User.query.get(1)\nuser.email = \"newemail@example.com\"\ndb.session.commit()\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#delete","title":"Delete","text":"<pre><code>user = User.query.get(1)\ndb.session.delete(user)\ndb.session.commit()\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#status-code-quick-reference","title":"Status Code Quick Reference","text":"Code Use When Example 200 Success (GET, PUT, PATCH, DELETE) Retrieved user successfully 201 Created (POST) User created successfully 400 Bad request (validation fail) Missing required field 401 Unauthorized (auth needed) Invalid token 404 Not found User with ID doesn't exist 500 Server error Database connection failed"},{"location":"PATTERN_CHEATSHEET.html#file-structure-reference","title":"File Structure Reference","text":""},{"location":"PATTERN_CHEATSHEET.html#small-project-levels-0-3","title":"Small Project (Levels 0-3)","text":"<pre><code>project/\n\u251c\u2500\u2500 app.py\n\u251c\u2500\u2500 extensions.py\n\u251c\u2500\u2500 models.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u2514\u2500\u2500 auth_service.py\n\u251c\u2500\u2500 errors.py\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 migrations/\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#large-project-levels-4-5","title":"Large Project (Levels 4-5)","text":"<pre><code>project/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 __init__.py       # create_app()\n\u2502   \u251c\u2500\u2500 extensions.py\n\u2502   \u251c\u2500\u2500 models/\n\u2502   \u2502   \u251c\u2500\u2500 user.py\n\u2502   \u2502   \u2514\u2500\u2500 book.py\n\u2502   \u251c\u2500\u2500 routes/\n\u2502   \u2502   \u251c\u2500\u2500 user_routes.py\n\u2502   \u2502   \u2514\u2500\u2500 auth_routes.py\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u251c\u2500\u2500 user_service.py\n\u2502   \u2502   \u2514\u2500\u2500 auth_service.py\n\u2502   \u2514\u2500\u2500 schemas/\n\u2502       \u2514\u2500\u2500 user_schema.py\n\u251c\u2500\u2500 config.py\n\u251c\u2500\u2500 wsgi.py\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 migrations/\n</code></pre>"},{"location":"PATTERN_CHEATSHEET.html#gitignore-template","title":".gitignore Template","text":"<pre><code># Virtual environment\nvenv/\nenv/\n\n# Python cache\n__pycache__/\n*.pyc\n*.pyo\n\n# Database\n*.db\n\n# Migrations (company policy)\nmigrations/\n\n# Environment variables\n.env\n\n# IDE\n.vscode/\n.idea/\n</code></pre> <p>Need more details? Refer back to the specific level documentation where each pattern was introduced.</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html","title":"Postman Beginner Guide - Part 1: Basics","text":""},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#goal","title":"Goal","text":"<p>Learn how to use Postman to test, debug, and interact with REST APIs. This first part covers installation, interface navigation, basic requests, collections, and environments. By the end of Part 1, you'll be able to efficiently test your Flask APIs and organize your requests.</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#table-of-contents","title":"Table of Contents","text":"<ol> <li>What is Postman?</li> <li>Installation and Setup</li> <li>Understanding the Postman Interface</li> <li>Sending Your First Request</li> <li>HTTP Methods Explained</li> <li>Working with Request Headers</li> <li>Request Body and Data Types</li> <li>Organizing Requests with Collections</li> <li>Using Environments and Variables</li> <li>Next Steps</li> </ol>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#what-is-postman","title":"What is Postman?","text":"<p>Postman is a powerful API development and testing tool that provides a user-friendly interface for making HTTP requests, testing APIs, and organizing your API workflows.</p> <p>Why use Postman?</p> <ul> <li>Visual Interface: Easy-to-use GUI instead of command-line tools</li> <li>Request Organization: Group related requests into collections</li> <li>Environment Management: Switch between dev, staging, and production easily</li> <li>Automated Testing: Write tests to validate API responses</li> <li>Team Collaboration: Share collections and work together</li> <li>Documentation: Auto-generate API documentation</li> <li>Mock Servers: Test frontend without backend ready</li> </ul> <p>Postman vs cURL</p> Feature Postman cURL Interface Graphical (GUI) Command-line Learning Curve Easier for beginners Requires terminal knowledge Organization Collections and folders Scripts and files Testing Built-in test scripts Manual validation Collaboration Built-in sharing Manual file sharing Automation Collection Runner, Newman Shell scripts <p>When to use Postman:</p> <ul> <li>Testing APIs during development</li> <li>Exploring and learning new APIs</li> <li>Sharing API requests with team</li> <li>Automated API testing</li> <li>API documentation</li> </ul> <p>When to use cURL:</p> <ul> <li>CI/CD pipelines</li> <li>Quick terminal testing</li> <li>Scripting and automation</li> <li>Server environments without GUI</li> </ul> <p>Both tools are valuable - use Postman for development and exploration, cURL for automation and scripts.</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#installation-and-setup","title":"Installation and Setup","text":""},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#windows-installation","title":"Windows Installation","text":"<p>Method 1: Direct Download (Recommended)</p> <ol> <li>Visit the Postman Download Page</li> <li>Click the \"Download for Windows\" button</li> <li>Run the downloaded <code>.exe</code> installer</li> <li>Follow the installation wizard</li> <li>Launch Postman from the Start menu</li> </ol> <p>Method 2: Using Chocolatey</p> <p>If you have Chocolatey package manager installed:</p> <pre><code>choco install postman\n</code></pre> <p>Method 3: Using Winget</p> <pre><code>winget install Postman.Postman\n</code></pre> <p>Verification:</p> <p>After installation, open Postman. You should see the welcome screen.</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#linux-installation","title":"Linux Installation","text":"<p>Method 1: Using Snap (Recommended for Ubuntu/Debian)</p> <pre><code># Install snapd if not already installed\nsudo apt update\nsudo apt install snapd\n\n# Install Postman\nsudo snap install postman\n</code></pre> <p>Method 2: Using Tarball (All Linux Distributions)</p> <ol> <li>Download the Linux tarball from Postman Download Page</li> <li>Extract the archive:</li> </ol> <pre><code># Extract to a directory\ntar -xzf Postman-linux-x64-*.tar.gz\n\n# Move to /opt for system-wide access\nsudo mv Postman /opt/\n\n# Create a symbolic link for easy access\nsudo ln -s /opt/Postman/Postman /usr/local/bin/postman\n</code></pre> <ol> <li>Create a desktop entry (optional):</li> </ol> <pre><code># Create desktop entry file\ncat &gt; ~/.local/share/applications/postman.desktop &lt;&lt; EOF\n[Desktop Entry]\nName=Postman\nExec=/opt/Postman/Postman\nIcon=/opt/Postman/app/resources/app/assets/icon.png\nTerminal=false\nType=Application\nCategories=Development;\nEOF\n</code></pre> <p>Method 3: Using AppImage</p> <ol> <li>Download the AppImage from the Postman website</li> <li>Make it executable:</li> </ol> <pre><code>chmod +x Postman-*.AppImage\n./Postman-*.AppImage\n</code></pre> <p>Verification:</p> <p>Launch Postman from terminal:</p> <pre><code>postman\n</code></pre> <p>Or from applications menu if desktop entry was created.</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#creating-a-postman-account","title":"Creating a Postman Account","text":"<p>Why create an account?</p> <ul> <li>Sync Across Devices: Access your collections from any computer</li> <li>Team Collaboration: Share collections with teammates</li> <li>Cloud Backup: Your work is saved automatically</li> <li>Advanced Features: Access to team workspaces and integrations</li> </ul> <p>Steps to Create Account:</p> <ol> <li>Open Postman</li> <li>Click \"Sign Up\" or \"Create Account\"</li> <li>Enter your email address</li> <li>Choose a password</li> <li>Verify your email (check inbox)</li> <li>Sign in to Postman</li> </ol> <p>Note: You can use Postman without an account, but you'll miss out on syncing and collaboration features.</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#initial-setup-and-preferences","title":"Initial Setup and Preferences","text":"<p>Accessing Settings:</p> <ul> <li>Windows/Linux: Click the gear icon (\u2699\ufe0f) in the top-right corner</li> <li>Or go to: File \u2192 Settings (or Postman \u2192 Preferences on Linux)</li> </ul> <p>Important Settings to Configure:</p> <ol> <li>Theme: Choose Light or Dark theme (Settings \u2192 Theme)</li> <li>Editor Font Size: Adjust for readability (Settings \u2192 Editor)</li> <li>Request Timeout: Set default timeout (Settings \u2192 General)</li> <li>SSL Certificate Verification: Keep enabled for security (Settings \u2192 General)</li> <li>Send Cookies: Enable to maintain session (Settings \u2192 General)</li> </ol> <p>Keyboard Shortcuts:</p> <ul> <li>Ctrl+N (Windows/Linux): New request</li> <li>Ctrl+S: Save request</li> <li>Ctrl+Enter: Send request</li> <li>Ctrl+/: Toggle comment</li> <li>Ctrl+B: Toggle sidebar</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#understanding-the-postman-interface","title":"Understanding the Postman Interface","text":""},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#main-components","title":"Main Components","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Postman                                 [\u2699\ufe0f] [\u2601\ufe0f] [\ud83d\udc64]     \u2502  \u2190 Top Bar\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502          \u2502  GET  [URL Bar]                    [Send]       \u2502  \u2190 Request Builder\n\u2502 Sidebar  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502          \u2502  \u2502 Params \u2502 Authorization \u2502 Headers \u2502 Body   \u2502   \u2502\n\u2502          \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502          \u2502                                                  \u2502\n\u2502          \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502          \u2502  \u2502 Response                                \u2502   \u2502  \u2190 Response Viewer\n\u2502          \u2502  \u2502 Status: 200 OK                          \u2502   \u2502\n\u2502          \u2502  \u2502 Body \u2502 Headers \u2502 Cookies \u2502 Test Results \u2502   \u2502\n\u2502          \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#sidebar-components","title":"Sidebar Components","text":"<p>1. Collections</p> <ul> <li>Organize related requests into folders</li> <li>Share collections with team</li> <li>Run multiple requests in sequence</li> </ul> <p>2. APIs</p> <ul> <li>Define API schemas</li> <li>Generate documentation</li> <li>Create mock servers</li> </ul> <p>3. Environments</p> <ul> <li>Store variables for different environments</li> <li>Switch between dev/staging/production</li> <li>Manage configuration values</li> </ul> <p>4. History</p> <ul> <li>View all requests you've sent</li> <li>Re-run previous requests</li> <li>Save requests to collections</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#request-builder","title":"Request Builder","text":"<p>1. HTTP Method Dropdown</p> <ul> <li>Select GET, POST, PUT, PATCH, DELETE, etc.</li> <li>Custom methods also supported</li> </ul> <p>2. URL Bar</p> <ul> <li>Enter the API endpoint URL</li> <li>Supports variables: <code>{{base_url}}/api/tasks/</code></li> <li>Auto-complete for saved URLs</li> </ul> <p>3. Tabs</p> <ul> <li>Params: Query parameters (e.g., <code>?page=1&amp;limit=10</code>)</li> <li>Authorization: Authentication settings</li> <li>Headers: HTTP headers</li> <li>Body: Request body (for POST, PUT, PATCH)</li> <li>Pre-request Script: JavaScript code before request</li> <li>Tests: JavaScript code to test response</li> </ul> <p>4. Send Button</p> <ul> <li>Executes the request</li> <li>Shows response below</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#response-viewer","title":"Response Viewer","text":"<p>1. Status Code</p> <ul> <li>Shows HTTP status (200, 404, 500, etc.)</li> <li>Color-coded (green = success, red = error)</li> </ul> <p>2. Response Time</p> <ul> <li>How long the request took</li> <li>Useful for performance testing</li> </ul> <p>3. Response Size</p> <ul> <li>Size of the response body</li> <li>Helps identify large responses</li> </ul> <p>4. Tabs</p> <ul> <li>Body: Response content (JSON, XML, HTML, etc.)</li> <li>Headers: Response headers</li> <li>Cookies: Set cookies</li> <li>Test Results: Results of test scripts</li> </ul> <p>5. Body View Options</p> <ul> <li>Pretty: Formatted JSON/XML</li> <li>Raw: Unformatted text</li> <li>Preview: Rendered HTML</li> <li>Visualize: Custom visualization</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#console","title":"Console","text":"<p>Access: Click \"Console\" button at bottom or press Ctrl+Alt+C</p> <p>What it shows:</p> <ul> <li>All HTTP requests and responses</li> <li>Console.log() output from scripts</li> <li>Errors and warnings</li> <li>Network request details</li> </ul> <p>Why it's useful:</p> <ul> <li>Debug request issues</li> <li>See exact headers sent</li> <li>View script execution logs</li> <li>Troubleshoot problems</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#sending-your-first-request","title":"Sending Your First Request","text":""},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#step-by-step-your-first-get-request","title":"Step-by-Step: Your First GET Request","text":"<p>Let's test a public API to get started:</p> <p>1. Create a New Request</p> <ul> <li>Click \"New\" button (top-left)</li> <li>Select \"HTTP Request\"</li> <li>Or press Ctrl+N</li> </ul> <p>2. Set the Request</p> <ul> <li>Method: Select GET (default)</li> <li>URL: Enter <code>https://jsonplaceholder.typicode.com/posts/1</code></li> <li>Click \"Send\"</li> </ul> <p>3. View the Response</p> <p>You should see:</p> <ul> <li>Status: <code>200 OK</code></li> <li>Body: JSON data with post information</li> <li>Time: Response time in milliseconds</li> </ul> <p>Congratulations! You've sent your first API request.</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#testing-your-local-flask-api","title":"Testing Your Local Flask API","text":"<p>Prerequisites:</p> <ul> <li>Flask server running on <code>http://127.0.0.1:5000</code></li> <li>An API endpoint (e.g., <code>/api/tasks/</code>)</li> </ul> <p>Steps:</p> <ol> <li>Create New Request</li> <li> <p>Click \"New\" \u2192 \"HTTP Request\"</p> </li> <li> <p>Configure Request</p> </li> <li>Method: GET</li> <li>URL: <code>http://127.0.0.1:5000/api/tasks/</code></li> <li> <p>Click \"Send\"</p> </li> <li> <p>View Response</p> </li> <li>If server is running: You'll see your API data</li> <li>If server is not running: Connection error</li> </ol> <p>Common First Request Issues:</p> Issue Solution \"Could not get response\" Check if Flask server is running (<code>python app.py</code> or <code>flask run</code>) \"Connection refused\" Verify URL and port (usually 5000 for Flask) \"404 Not Found\" Check URL path matches your Flask routes and blueprints \"CORS error\" Add CORS headers using <code>flask-cors</code> in your Flask app"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#http-methods-explained","title":"HTTP Methods Explained","text":""},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#get-retrieve-data","title":"GET - Retrieve Data","text":"<p>Purpose: Fetch data from the server</p> <p>When to use:</p> <ul> <li>List all items: <code>GET /api/tasks/</code></li> <li>Get single item: <code>GET /api/tasks/1/</code></li> <li>Search/filter: <code>GET /api/tasks/?completed=true</code></li> </ul> <p>Example in Postman:</p> <pre><code>Method: GET\nURL: http://127.0.0.1:5000/api/tasks/\n</code></pre> <p>No body required - data comes in URL or query parameters.</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#post-create-new-resource","title":"POST - Create New Resource","text":"<p>Purpose: Create a new item on the server</p> <p>When to use:</p> <ul> <li>Create new task: <code>POST /api/tasks/</code></li> <li>Register user: <code>POST /api/register/</code></li> <li>Submit form data</li> </ul> <p>Example in Postman:</p> <pre><code>Method: POST\nURL: http://127.0.0.1:5000/api/tasks/\nBody (raw JSON):\n{\n  \"title\": \"Learn Postman\",\n  \"description\": \"Complete the Postman guide\",\n  \"completed\": false\n}\n</code></pre> <p>Important: Set Content-Type header to <code>application/json</code></p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#put-full-update","title":"PUT - Full Update","text":"<p>Purpose: Replace entire resource with new data</p> <p>When to use:</p> <ul> <li>Update all fields of an item</li> <li>Replace existing resource completely</li> </ul> <p>Example in Postman:</p> <pre><code>Method: PUT\nURL: http://127.0.0.1:5000/api/tasks/1/\nBody (raw JSON):\n{\n  \"title\": \"Updated Task\",\n  \"description\": \"Updated description\",\n  \"completed\": true\n}\n</code></pre> <p>Note: PUT requires ALL fields, even if unchanged.</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#patch-partial-update","title":"PATCH - Partial Update","text":"<p>Purpose: Update only specific fields</p> <p>When to use:</p> <ul> <li>Update single field: <code>PATCH /api/tasks/1/</code> with <code>{\"completed\": true}</code></li> <li>Update multiple fields without sending all data</li> </ul> <p>Example in Postman:</p> <pre><code>Method: PATCH\nURL: http://127.0.0.1:5000/api/tasks/1/\nBody (raw JSON):\n{\n  \"completed\": true\n}\n</code></pre> <p>Note: PATCH only updates provided fields.</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#delete-remove-resource","title":"DELETE - Remove Resource","text":"<p>Purpose: Delete an item from the server</p> <p>When to use:</p> <ul> <li>Delete task: <code>DELETE /api/tasks/1/</code></li> <li>Remove user account</li> <li>Delete any resource</li> </ul> <p>Example in Postman:</p> <pre><code>Method: DELETE\nURL: http://127.0.0.1:5000/api/tasks/1/\n</code></pre> <p>No body required - item ID is in URL.</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#summary-table","title":"Summary Table","text":"Method Purpose Body Required? Idempotent? GET Read data No Yes POST Create new Yes No PUT Full update Yes Yes PATCH Partial update Yes No DELETE Delete No Yes <p>Idempotent = Can be called multiple times with same result.</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#working-with-request-headers","title":"Working with Request Headers","text":""},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#what-are-headers","title":"What are Headers?","text":"<p>Headers are metadata sent with HTTP requests that provide additional information about the request or response.</p> <p>Common Headers:</p> <ul> <li>Content-Type: Type of data being sent (JSON, form-data, etc.)</li> <li>Authorization: Authentication credentials</li> <li>Accept: What response format you want</li> <li>User-Agent: Information about the client</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#adding-headers-in-postman","title":"Adding Headers in Postman","text":"<p>Method 1: Headers Tab</p> <ol> <li>Click \"Headers\" tab in request builder</li> <li>Click \"Add Header\" or use key-value fields</li> <li>Enter header name (e.g., <code>Content-Type</code>)</li> <li>Enter header value (e.g., <code>application/json</code>)</li> <li>Postman auto-completes common headers</li> </ol> <p>Method 2: Bulk Edit</p> <ol> <li>Click \"Bulk Edit\" in Headers tab</li> <li>Paste headers in format:</li> </ol> <pre><code>Content-Type: application/json\nAccept: application/json\nAuthorization: Bearer token123\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#common-headers-for-apis","title":"Common Headers for APIs","text":"<p>Content-Type</p> <pre><code>Content-Type: application/json\n</code></pre> <p>Why: Tells server you're sending JSON data. Required for POST/PUT/PATCH with JSON body.</p> <p>Accept</p> <pre><code>Accept: application/json\n</code></pre> <p>Why: Tells server you want JSON response. Your Flask API should be configured to return JSON by default, but it's still good practice to specify.</p> <p>Authorization (Bearer Token)</p> <pre><code>Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGc...\n</code></pre> <p>Why: Authenticates requests. Used with JWT or token authentication.</p> <p>Authorization (Basic Auth)</p> <pre><code>Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=\n</code></pre> <p>Why: Basic username/password authentication (base64 encoded).</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#preset-headers","title":"Preset Headers","text":"<p>Postman provides preset headers for common scenarios:</p> <ol> <li>Click \"Presets\" dropdown in Headers tab</li> <li>Select from:</li> <li>JSON: Sets <code>Content-Type: application/json</code></li> <li>XML: Sets <code>Content-Type: application/xml</code></li> <li>Form URL Encoded: Sets appropriate content type</li> <li>Multipart Form: For file uploads</li> </ol>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#managing-headers","title":"Managing Headers","text":"<p>Disable Header Temporarily:</p> <ul> <li>Uncheck the checkbox next to header</li> <li>Header stays but won't be sent</li> </ul> <p>Delete Header:</p> <ul> <li>Hover over header row</li> <li>Click \"X\" icon</li> </ul> <p>Duplicate Header:</p> <ul> <li>Right-click header</li> <li>Select \"Duplicate\"</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#request-body-and-data-types","title":"Request Body and Data Types","text":""},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#when-to-use-request-body","title":"When to Use Request Body","text":"<p>Request body is used with:</p> <ul> <li>POST: Creating new resources</li> <li>PUT: Full updates</li> <li>PATCH: Partial updates</li> </ul> <p>GET and DELETE don't use request body - data goes in URL or headers.</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#body-types-in-postman","title":"Body Types in Postman","text":"<p>Postman supports multiple body formats:</p> <p>1. none</p> <ul> <li>No body (for GET, DELETE requests)</li> <li>Default for GET requests</li> </ul> <p>2. form-data</p> <ul> <li>HTML form submission</li> <li>Key-value pairs</li> <li>Supports file uploads</li> </ul> <p>3. x-www-form-urlencoded</p> <ul> <li>URL-encoded form data</li> <li>Similar to form-data but encoded differently</li> <li>No file upload support</li> </ul> <p>4. raw</p> <ul> <li>Send raw data (JSON, XML, text, etc.)</li> <li>Most common for REST APIs</li> <li>Choose format from dropdown (JSON, XML, HTML, Text)</li> </ul> <p>5. binary</p> <ul> <li>Upload binary files (images, PDFs, etc.)</li> <li>Select file from computer</li> </ul> <p>6. GraphQL</p> <ul> <li>For GraphQL queries and mutations</li> <li>Advanced feature</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#json-body-most-common","title":"JSON Body (Most Common)","text":"<p>When to use: Most Flask APIs use JSON</p> <p>Steps:</p> <ol> <li>Select \"Body\" tab</li> <li>Choose \"raw\"</li> <li>Select \"JSON\" from dropdown (or \"Text\" and type JSON)</li> <li>Enter JSON data:</li> </ol> <pre><code>{\n  \"title\": \"My Task\",\n  \"description\": \"Task description\",\n  \"completed\": false\n}\n</code></pre> <p>Example: Creating a Task</p> <pre><code>Method: POST\nURL: http://127.0.0.1:5000/api/tasks/\nHeaders:\n  Content-Type: application/json\nBody (raw JSON):\n{\n  \"title\": \"Learn Postman\",\n  \"description\": \"Complete Postman guide\",\n  \"completed\": false\n}\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#form-data","title":"Form Data","text":"<p>When to use: HTML forms, file uploads</p> <p>Steps:</p> <ol> <li>Select \"Body\" tab</li> <li>Choose \"form-data\"</li> <li>Add key-value pairs:</li> <li>Key: <code>title</code></li> <li>Value: <code>My Task</code></li> <li>For files, change type to \"File\" and select file</li> </ol> <p>Example:</p> <pre><code>Method: POST\nURL: http://127.0.0.1:5000/api/tasks/\nBody (form-data):\n  title: \"My Task\"\n  description: \"Task description\"\n  file: [Select File]\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#url-encoded-form","title":"URL-Encoded Form","text":"<p>When to use: Traditional form submissions</p> <p>Steps:</p> <ol> <li>Select \"Body\" tab</li> <li>Choose \"x-www-form-urlencoded\"</li> <li>Add key-value pairs</li> </ol> <p>Example:</p> <pre><code>Method: POST\nURL: http://127.0.0.1:5000/api/tasks/\nBody (x-www-form-urlencoded):\n  title: My Task\n  description: Task description\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#binary-body","title":"Binary Body","text":"<p>When to use: Uploading files directly</p> <p>Steps:</p> <ol> <li>Select \"Body\" tab</li> <li>Choose \"binary\"</li> <li>Click \"Select File\"</li> <li>Choose file from computer</li> </ol> <p>Example:</p> <pre><code>Method: POST\nURL: http://127.0.0.1:5000/api/tasks/1/upload/\nBody (binary):\n  [Select PDF file]\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#json-formatting-tips","title":"JSON Formatting Tips","text":"<p>Valid JSON:</p> <pre><code>{\n  \"title\": \"Task\",\n  \"completed\": false,\n  \"tags\": [\"work\", \"urgent\"]\n}\n</code></pre> <p>Invalid JSON (Common Mistakes):</p> <pre><code>// \u274c Trailing comma\n{\n  \"title\": \"Task\",\n  \"completed\": false,  // \u2190 Remove this comma\n}\n\n// \u274c Single quotes (use double quotes)\n{\n  'title': 'Task'  // \u274c Wrong\n}\n\n// \u274c Missing quotes around keys\n{\n  title: \"Task\"  // \u274c Wrong\n}\n</code></pre> <p>Postman Auto-Formatting:</p> <ul> <li>Postman validates JSON as you type</li> <li>Red underline = syntax error</li> <li>Click \"Beautify\" to format JSON nicely</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#organizing-requests-with-collections","title":"Organizing Requests with Collections","text":""},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#what-are-collections","title":"What are Collections?","text":"<p>Collections are groups of related API requests. Think of them as folders for organizing your API testing.</p> <p>Why use Collections?</p> <ul> <li>Organization: Group related requests together</li> <li>Sharing: Share entire collection with team</li> <li>Automation: Run all requests in sequence</li> <li>Documentation: Auto-generate API docs</li> <li>Version Control: Export/import collections</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#creating-a-collection","title":"Creating a Collection","text":"<p>Method 1: New Collection Button</p> <ol> <li>Click \"New\" button (top-left)</li> <li>Select \"Collection\"</li> <li>Enter collection name (e.g., \"Flask Task API\")</li> <li>(Optional) Add description</li> <li>Click \"Create\"</li> </ol> <p>Method 2: From Request</p> <ol> <li>Create or open a request</li> <li>Click \"Save\" button</li> <li>Click \"+ Create Collection\"</li> <li>Enter name and create</li> <li>Save request to new collection</li> </ol> <p>Method 3: Sidebar</p> <ol> <li>Right-click in sidebar</li> <li>Select \"New Collection\"</li> <li>Enter name and create</li> </ol>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#adding-requests-to-collection","title":"Adding Requests to Collection","text":"<p>Method 1: Save Existing Request</p> <ol> <li>Create or modify a request</li> <li>Click \"Save\" button</li> <li>Select collection from dropdown</li> <li>(Optional) Change request name</li> <li>Click \"Save\"</li> </ol> <p>Method 2: Drag and Drop</p> <ol> <li>Find request in History</li> <li>Drag it to collection in sidebar</li> <li>Drop to add</li> </ol> <p>Method 3: Create in Collection</p> <ol> <li>Right-click collection</li> <li>Select \"Add Request\"</li> <li>Configure request</li> <li>It's automatically saved to collection</li> </ol>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#organizing-with-folders","title":"Organizing with Folders","text":"<p>Create Folder:</p> <ol> <li>Right-click collection</li> <li>Select \"Add Folder\"</li> <li>Enter folder name (e.g., \"Authentication\", \"Tasks\", \"Users\")</li> </ol> <p>Organize Requests:</p> <ul> <li>Drag requests into folders</li> <li>Create nested folders for better organization</li> </ul> <p>Example Structure:</p> <pre><code>Flask API Collection\n\u251c\u2500\u2500 Authentication\n\u2502   \u251c\u2500\u2500 Login\n\u2502   \u251c\u2500\u2500 Register\n\u2502   \u2514\u2500\u2500 Refresh Token\n\u251c\u2500\u2500 Tasks\n\u2502   \u251c\u2500\u2500 List Tasks\n\u2502   \u251c\u2500\u2500 Create Task\n\u2502   \u251c\u2500\u2500 Get Task\n\u2502   \u251c\u2500\u2500 Update Task\n\u2502   \u2514\u2500\u2500 Delete Task\n\u2514\u2500\u2500 Users\n    \u251c\u2500\u2500 List Users\n    \u2514\u2500\u2500 Get Profile\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#collection-settings","title":"Collection Settings","text":"<p>Access: Right-click collection \u2192 \"Edit\"</p> <p>Settings:</p> <ol> <li>Name: Collection name</li> <li>Description: What this collection is for</li> <li>Authorization: Set auth for all requests (can override per request)</li> <li>Pre-request Script: Run before each request</li> <li>Tests: Run after each request</li> <li>Variables: Collection-level variables</li> </ol>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#collection-variables","title":"Collection Variables","text":"<p>Why: Store values used across multiple requests in the collection.</p> <p>Example: Base URL for all requests</p> <p>Set Collection Variable:</p> <ol> <li>Right-click collection \u2192 \"Edit\"</li> <li>Go to \"Variables\" tab</li> <li>Add variable:</li> <li>Variable: <code>base_url</code></li> <li>Initial Value: <code>http://127.0.0.1:5000</code></li> <li>Current Value: <code>http://127.0.0.1:5000</code></li> <li>Click \"Save\"</li> </ol> <p>Use in Requests:</p> <p>In URL bar, use: <code>{{base_url}}/api/tasks/</code></p> <p>Postman replaces <code>{{base_url}}</code> with the actual value.</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#running-collections","title":"Running Collections","text":"<p>Collection Runner:</p> <ol> <li>Right-click collection</li> <li>Select \"Run collection\"</li> <li>Configure run settings:</li> <li>Select requests to run</li> <li>Set iterations (how many times)</li> <li>Set delay between requests</li> <li>Click \"Run Flask API Collection\"</li> <li>View results</li> </ol> <p>Use Cases:</p> <ul> <li>Test all endpoints after code changes</li> <li>Verify API still works</li> <li>Run automated tests</li> <li>Performance testing</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#sharing-collections","title":"Sharing Collections","text":"<p>Export Collection:</p> <ol> <li>Right-click collection</li> <li>Select \"Export\"</li> <li>Choose format (Collection v2.1 recommended)</li> <li>Save file</li> <li>Share file with team</li> </ol> <p>Import Collection:</p> <ol> <li>Click \"Import\" button (top-left)</li> <li>Select \"File\" or \"Link\"</li> <li>Choose collection file or paste link</li> <li>Click \"Import\"</li> </ol> <p>Share via Link (Postman Account Required):</p> <ol> <li>Right-click collection</li> <li>Select \"Share Collection\"</li> <li>Choose visibility (Team, Public, Private)</li> <li>Copy link and share</li> </ol>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#using-environments-and-variables","title":"Using Environments and Variables","text":""},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#what-are-environments","title":"What are Environments?","text":"<p>Environments are sets of variables that you can switch between easily. Common use cases:</p> <ul> <li>Development: <code>http://127.0.0.1:5000</code></li> <li>Staging: <code>https://staging-api.example.com</code></li> <li>Production: <code>https://api.example.com</code></li> </ul> <p>Why use Environments?</p> <ul> <li>Quick Switching: Change base URL with one click</li> <li>No Manual Editing: Don't change URLs in every request</li> <li>Team Consistency: Everyone uses same environment values</li> <li>Security: Store sensitive data (API keys) securely</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#creating-an-environment","title":"Creating an Environment","text":"<p>Steps:</p> <ol> <li>Click \"Environments\" in sidebar (or eye icon in top-right)</li> <li>Click \"+\" button or \"Create Environment\"</li> <li>Enter environment name (e.g., \"Development\")</li> <li>Add variables:</li> <li>Variable: <code>base_url</code></li> <li>Initial Value: <code>http://127.0.0.1:5000</code></li> <li>Current Value: <code>http://127.0.0.1:5000</code></li> <li>Click \"Save\"</li> </ol> <p>Example Environment Variables:</p> Variable Initial Value Current Value <code>base_url</code> <code>http://127.0.0.1:5000</code> <code>http://127.0.0.1:5000</code> <code>api_key</code> <code>dev_key_123</code> <code>dev_key_123</code> <code>token</code> (leave empty) (will be set dynamically)"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#switching-environments","title":"Switching Environments","text":"<p>Method 1: Dropdown</p> <ol> <li>Click environment dropdown (top-right, shows \"No Environment\")</li> <li>Select environment (e.g., \"Development\")</li> <li>All <code>{{variable}}</code> references update automatically</li> </ol> <p>Method 2: Quick Switch</p> <ul> <li>Use keyboard shortcut (if configured)</li> <li>Or click environment name in top-right</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#using-variables-in-requests","title":"Using Variables in Requests","text":"<p>Syntax: <code>{{variable_name}}</code></p> <p>Example:</p> <pre><code>URL: {{base_url}}/api/tasks/\n</code></pre> <p>When \"Development\" environment is selected and <code>base_url = http://127.0.0.1:5000</code>, the actual URL becomes:</p> <pre><code>http://127.0.0.1:5000/api/tasks/\n</code></pre> <p>Where Variables Work:</p> <ul> <li>URL: <code>{{base_url}}/api/tasks/</code></li> <li>Headers: <code>Authorization: Bearer {{token}}</code></li> <li>Body: <code>{\"user_id\": {{user_id}}}</code></li> <li>Query Params: <code>?page={{page_number}}</code></li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#variable-scopes","title":"Variable Scopes","text":"<p>Variables have different scopes (priority order):</p> <ol> <li>Local Variables (highest priority)</li> <li>Set in scripts</li> <li>Only available in current request</li> <li> <p>Example: <code>pm.variables.set(\"temp_id\", \"123\")</code></p> </li> <li> <p>Environment Variables</p> </li> <li>Defined in environment</li> <li>Available to all requests when environment is active</li> <li> <p>Example: <code>{{base_url}}</code></p> </li> <li> <p>Collection Variables</p> </li> <li>Defined in collection settings</li> <li>Available to all requests in collection</li> <li> <p>Example: <code>{{api_version}}</code></p> </li> <li> <p>Global Variables (lowest priority)</p> </li> <li>Available everywhere</li> <li>Use sparingly</li> <li>Example: <code>{{global_timeout}}</code></li> </ol> <p>Resolution Order: Local \u2192 Environment \u2192 Collection \u2192 Global</p>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#dynamic-variables","title":"Dynamic Variables","text":"<p>Postman provides built-in dynamic variables:</p> <p>Random Values:</p> <ul> <li><code>{{$randomInt}}</code>: Random integer (0-1000)</li> <li><code>{{$randomFirstName}}</code>: Random first name</li> <li><code>{{$randomLastName}}</code>: Random last name</li> <li><code>{{$randomEmail}}</code>: Random email</li> <li><code>{{$randomUUID}}</code>: Random UUID</li> </ul> <p>Example:</p> <pre><code>{\n  \"name\": \"{{$randomFirstName}} {{$randomLastName}}\",\n  \"email\": \"{{$randomEmail}}\",\n  \"age\": {{$randomInt}}\n}\n</code></pre> <p>Timestamp:</p> <ul> <li><code>{{$timestamp}}</code>: Current Unix timestamp</li> <li><code>{{$isoTimestamp}}</code>: ISO 8601 timestamp</li> </ul> <p>Example:</p> <pre><code>{\n  \"created_at\": \"{{$isoTimestamp}}\"\n}\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#setting-variables-from-response","title":"Setting Variables from Response","text":"<p>Why: Extract data from response and use in next request.</p> <p>Example: Save JWT Token</p> <ol> <li>Login Request (POST <code>/api/token/</code>)</li> </ol> <p>In Tests tab:</p> <pre><code>// Parse response\nconst response = pm.response.json();\n\n// Save token to environment variable\npm.environment.set(\"access_token\", response.access);\npm.environment.set(\"refresh_token\", response.refresh);\n</code></pre> <ol> <li>Use Token in Next Request</li> </ol> <p>In Authorization tab:</p> <ul> <li>Type: Bearer Token</li> <li>Token: <code>{{access_token}}</code></li> </ul> <p>Or in Headers:</p> <pre><code>Authorization: Bearer {{access_token}}\n</code></pre> <p>Common Use Cases:</p> <ul> <li>Save authentication tokens</li> <li>Extract IDs from created resources</li> <li>Store pagination tokens</li> <li>Capture session data</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#environment-best-practices","title":"Environment Best Practices","text":"<p>1. Use Descriptive Names</p> <pre><code>\u2705 Good: base_url, api_key, user_id\n\u274c Bad: url, key, id\n</code></pre> <p>2. Separate Environments</p> <ul> <li>Don't mix dev and prod values</li> <li>Create separate environments for each</li> </ul> <p>3. Use Initial Values</p> <ul> <li>Set default/example values</li> <li>Team members can override with Current Value</li> </ul> <p>4. Secure Sensitive Data</p> <ul> <li>Don't commit environment files with real API keys</li> <li>Use Postman's built-in secret management</li> <li>Rotate keys regularly</li> </ul> <p>5. Document Variables</p> <ul> <li>Add descriptions in environment</li> <li>Document what each variable is for</li> <li>Note any special requirements</li> </ul>"},{"location":"POSTMAN_GUIDE_PART1_BASICS.html#next-steps","title":"Next Steps","text":"<p>Congratulations! You've completed Part 1 of the Postman guide. You now know how to:</p> <ul> <li>\u2705 Install Postman on Windows and Linux</li> <li>\u2705 Navigate the Postman interface</li> <li>\u2705 Send basic HTTP requests (GET, POST, PUT, PATCH, DELETE)</li> <li>\u2705 Work with headers and request bodies</li> <li>\u2705 Organize requests into collections</li> <li>\u2705 Use environments and variables</li> </ul> <p>Continue to Part 2 to learn:</p> <ul> <li>Authentication (JWT, Token, OAuth)</li> <li>Writing tests and scripts</li> <li>Automation and collection runner</li> <li>Mock servers and documentation</li> <li>Advanced Flask API testing examples</li> <li>Troubleshooting common issues</li> </ul> <p>Practice Exercises:</p> <ol> <li>Create a collection for your Flask API</li> <li>Set up Development and Production environments</li> <li>Create requests for all CRUD operations</li> <li>Use variables for base URL and authentication</li> <li>Organize requests into logical folders</li> </ol> <p>Ready for more? Continue to Postman Guide - Part 2: Advanced Features</p>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html","title":"Postman Beginner Guide - Part 2: Advanced Features","text":""},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#goal","title":"Goal","text":"<p>Master advanced Postman features including authentication, automated testing, scripting, mock servers, and comprehensive Flask API testing. By the end of Part 2, you'll be able to build robust API test suites and automate your testing workflow.</p>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#table-of-contents","title":"Table of Contents","text":"<ol> <li>Authentication in Postman</li> <li>Writing Tests and Scripts</li> <li>Pre-request Scripts</li> <li>Running Collections and Automation</li> <li>Mock Servers</li> <li>API Documentation</li> <li>Testing Flask APIs - Step by Step</li> <li>Common Errors and Solutions</li> <li>Best Practices</li> <li>Exercises</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#authentication-in-postman","title":"Authentication in Postman","text":""},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#why-authentication-matters","title":"Why Authentication Matters","text":"<p>Most APIs require authentication to:</p> <ul> <li>Protect data: Only authorized users can access</li> <li>Track usage: Know who made which requests</li> <li>Enforce permissions: Control what users can do</li> <li>Security: Prevent unauthorized access</li> </ul> <p>Real-world analogy: Authentication is like showing ID at a bank - you need to prove who you are before accessing your account.</p>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#authentication-types-in-postman","title":"Authentication Types in Postman","text":"<p>Postman supports multiple authentication methods:</p> <ol> <li>No Auth: Public APIs (no authentication)</li> <li>Bearer Token: JWT tokens, API keys</li> <li>Basic Auth: Username and password</li> <li>API Key: Custom API key authentication</li> <li>OAuth 2.0: Advanced authentication protocol</li> <li>Digest Auth: Challenge-response authentication</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#bearer-token-authentication-jwt","title":"Bearer Token Authentication (JWT)","text":"<p>Most common for Flask APIs - Used with JWT (JSON Web Tokens) or simple token authentication.</p> <p>How it works:</p> <ol> <li>User logs in \u2192 Server returns JWT token</li> <li>Client stores token</li> <li>Client sends token in <code>Authorization</code> header: <code>Bearer &lt;token&gt;</code></li> <li>Server validates token and grants access</li> </ol> <p>Setting up in Postman:</p> <p>Method 1: Authorization Tab</p> <ol> <li>Open request</li> <li>Go to \"Authorization\" tab</li> <li>Type: Select \"Bearer Token\"</li> <li>Token: Enter your token (or use variable: <code>{{access_token}}</code>)</li> <li>Click \"Send\"</li> </ol> <p>Method 2: Headers Tab</p> <ol> <li>Go to \"Headers\" tab</li> <li>Add header:</li> <li>Key: <code>Authorization</code></li> <li>Value: <code>Bearer your_token_here</code></li> <li>Or: <code>Bearer {{access_token}}</code></li> </ol> <p>Example: Flask JWT Authentication</p> <p>Step 1: Get Token (Login Request)</p> <pre><code>Method: POST\nURL: {{base_url}}/api/token/\nHeaders:\n  Content-Type: application/json\nBody (raw JSON):\n{\n  \"username\": \"admin\",\n  \"password\": \"password123\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n  \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",\n  \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"\n}\n</code></pre> <p>Step 2: Save Token to Environment</p> <p>In Tests tab of login request:</p> <pre><code>// Parse response\nconst response = pm.response.json();\n\n// Save tokens to environment\npm.environment.set(\"access_token\", response.access);\npm.environment.set(\"refresh_token\", response.refresh);\n\n// Optional: Set token expiration time\npm.environment.set(\"token_expires_at\", Date.now() + 3600000); // 1 hour\n</code></pre> <p>Step 3: Use Token in Protected Requests</p> <p>In Authorization tab:</p> <ul> <li>Type: Bearer Token</li> <li>Token: <code>{{access_token}}</code></li> </ul> <p>Now all requests will automatically include: <code>Authorization: Bearer &lt;token&gt;</code></p>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#basic-authentication","title":"Basic Authentication","text":"<p>When to use: Simple username/password authentication.</p> <p>Setting up:</p> <ol> <li>Go to \"Authorization\" tab</li> <li>Type: Select \"Basic Auth\"</li> <li>Username: Enter username</li> <li>Password: Enter password</li> <li>Postman automatically encodes credentials</li> </ol> <p>How it works:</p> <ul> <li>Postman encodes <code>username:password</code> in base64</li> <li>Sends as: <code>Authorization: Basic &lt;encoded_credentials&gt;</code></li> </ul> <p>Example:</p> <pre><code>Username: admin\nPassword: secret123\n</code></pre> <p>Postman sends: <code>Authorization: Basic YWRtaW46c2VjcmV0MTIz</code></p> <p>Using Variables:</p> <pre><code>Username: {{username}}\nPassword: {{password}}\n</code></pre> <p>Store credentials in environment variables for security.</p>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#api-key-authentication","title":"API Key Authentication","text":"<p>When to use: Custom API key authentication (not standard Bearer Token).</p> <p>Setting up:</p> <ol> <li>Go to \"Authorization\" tab</li> <li>Type: Select \"API Key\"</li> <li>Key: Header name (e.g., <code>X-API-Key</code>)</li> <li>Value: Your API key</li> <li>Add to: Choose where to add (Header, Query Params)</li> </ol> <p>Example:</p> <pre><code>Key: X-API-Key\nValue: {{api_key}}\nAdd to: Header\n</code></pre> <p>This adds header: <code>X-API-Key: your_api_key_here</code></p> <p>Common API Key Patterns:</p> <ul> <li>Header: <code>X-API-Key: &lt;key&gt;</code></li> <li>Header: <code>Authorization: ApiKey &lt;key&gt;</code></li> <li>Query Param: <code>?api_key=&lt;key&gt;</code></li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#oauth-20-authentication","title":"OAuth 2.0 Authentication","text":"<p>When to use: Advanced authentication with access tokens, refresh tokens, and scopes.</p> <p>OAuth 2.0 Flow:</p> <ol> <li>Authorization Request: Get authorization code</li> <li>Token Request: Exchange code for access token</li> <li>Access Resource: Use access token for API calls</li> <li>Refresh Token: Get new access token when expired</li> </ol> <p>Setting up in Postman:</p> <ol> <li>Go to \"Authorization\" tab</li> <li>Type: Select \"OAuth 2.0\"</li> <li>Configure:</li> <li>Grant Type: Authorization Code, Client Credentials, etc.</li> <li>Auth URL: Authorization endpoint</li> <li>Access Token URL: Token endpoint</li> <li>Client ID: Your OAuth client ID</li> <li>Client Secret: Your OAuth client secret</li> <li>Scope: Requested permissions</li> <li>Click \"Get New Access Token\"</li> <li>Click \"Use Token\"</li> </ol> <p>For Flask with OAuth (less common in this guide):</p> <p>Most Flask APIs in this curriculum use JWT (Bearer Token) instead of full OAuth 2.0. Use the Bearer Token method above.</p>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#digest-authentication","title":"Digest Authentication","text":"<p>When to use: Challenge-response authentication (less common).</p> <p>Setting up:</p> <ol> <li>Go to \"Authorization\" tab</li> <li>Type: Select \"Digest Auth\"</li> <li>Enter Username and Password</li> <li>Postman handles the challenge-response automatically</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#collection-level-authentication","title":"Collection-Level Authentication","text":"<p>Why: Set authentication once for entire collection.</p> <p>Setting up:</p> <ol> <li>Right-click collection \u2192 \"Edit\"</li> <li>Go to \"Authorization\" tab</li> <li>Select authentication type</li> <li>Configure credentials</li> <li>All requests in collection inherit this auth</li> </ol> <p>Override per Request:</p> <ul> <li>Individual requests can override collection auth</li> <li>Set different auth in request's Authorization tab</li> </ul> <p>Example Collection Auth:</p> <pre><code>Type: Bearer Token\nToken: {{access_token}}\n</code></pre> <p>All requests in collection automatically use this token.</p>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#token-refresh-flow","title":"Token Refresh Flow","text":"<p>Problem: JWT tokens expire. Need to refresh automatically.</p> <p>Solution: Pre-request script to check and refresh token.</p> <p>Step 1: Check Token Expiration</p> <p>In Pre-request Script tab of protected requests:</p> <pre><code>// Get token expiration time\nconst tokenExpiresAt = pm.environment.get(\"token_expires_at\");\nconst now = Date.now();\n\n// If token expired or expires in next 5 minutes, refresh it\nif (!tokenExpiresAt || now &gt;= (tokenExpiresAt - 300000)) {\n    // Token expired or expiring soon, refresh it\n    pm.sendRequest({\n        url: pm.environment.get(\"base_url\") + \"/api/token/refresh/\",\n        method: \"POST\",\n        header: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: {\n            mode: \"raw\",\n            raw: JSON.stringify({\n                refresh: pm.environment.get(\"refresh_token\")\n            })\n        }\n    }, function (err, res) {\n        if (!err &amp;&amp; res.code === 200) {\n            const response = res.json();\n            pm.environment.set(\"access_token\", response.access);\n            pm.environment.set(\"token_expires_at\", Date.now() + 3600000);\n        }\n    });\n}\n</code></pre> <p>Step 2: Use Token</p> <p>Token is automatically refreshed before request, so it's always valid.</p>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#writing-tests-and-scripts","title":"Writing Tests and Scripts","text":""},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#why-write-tests","title":"Why Write Tests?","text":"<p>Benefits:</p> <ul> <li>Automated Validation: Check if API works correctly</li> <li>Catch Bugs Early: Find issues before production</li> <li>Documentation: Tests show expected behavior</li> <li>Regression Testing: Ensure changes don't break existing features</li> <li>CI/CD Integration: Run tests in automated pipelines</li> </ul> <p>Real-world analogy: Tests are like quality checks - you verify the product works before shipping.</p>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#test-scripts-tab","title":"Test Scripts Tab","text":"<p>Location: \"Tests\" tab in request builder</p> <p>When tests run: After response is received</p> <p>Language: JavaScript (Postman uses a JavaScript runtime)</p>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#basic-test-examples","title":"Basic Test Examples","text":"<p>Test 1: Check Status Code</p> <pre><code>pm.test(\"Status code is 200\", function () {\n    pm.response.to.have.status(200);\n});\n</code></pre> <p>Test 2: Check Response Time</p> <pre><code>pm.test(\"Response time is less than 500ms\", function () {\n    pm.expect(pm.response.responseTime).to.be.below(500);\n});\n</code></pre> <p>Test 3: Check Response Body Contains Data</p> <pre><code>pm.test(\"Response has tasks array\", function () {\n    const response = pm.response.json();\n    pm.expect(response).to.have.property(\"results\");\n    pm.expect(response.results).to.be.an(\"array\");\n});\n</code></pre> <p>Test 4: Check Specific Field Value</p> <pre><code>pm.test(\"Task has title field\", function () {\n    const response = pm.response.json();\n    pm.expect(response).to.have.property(\"title\");\n    pm.expect(response.title).to.be.a(\"string\");\n});\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#common-test-assertions","title":"Common Test Assertions","text":"<p>Status Code Tests:</p> <pre><code>pm.test(\"Status is 200\", () =&gt; pm.response.to.have.status(200));\npm.test(\"Status is 201\", () =&gt; pm.response.to.have.status(201));\npm.test(\"Status is not 404\", () =&gt; pm.expect(pm.response.code).to.not.equal(404));\npm.test(\"Status is success\", () =&gt; pm.response.to.be.success);\npm.test(\"Status is client error\", () =&gt; pm.response.to.be.clientError);\npm.test(\"Status is server error\", () =&gt; pm.response.to.be.serverError);\n</code></pre> <p>Response Time Tests:</p> <pre><code>pm.test(\"Response time &lt; 200ms\", () =&gt; {\n    pm.expect(pm.response.responseTime).to.be.below(200);\n});\n</code></pre> <p>Header Tests:</p> <pre><code>pm.test(\"Content-Type is JSON\", () =&gt; {\n    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n});\n</code></pre> <p>Body Tests:</p> <pre><code>pm.test(\"Response is JSON\", () =&gt; {\n    pm.response.to.be.json;\n});\n\npm.test(\"Response has property\", () =&gt; {\n    const json = pm.response.json();\n    pm.expect(json).to.have.property(\"id\");\n});\n\npm.test(\"Property value matches\", () =&gt; {\n    const json = pm.response.json();\n    pm.expect(json.completed).to.be.false;\n});\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#advanced-test-examples","title":"Advanced Test Examples","text":"<p>Test: Validate JSON Schema</p> <pre><code>pm.test(\"Response matches schema\", function () {\n    const schema = {\n        type: \"object\",\n        properties: {\n            id: { type: \"number\" },\n            title: { type: \"string\" },\n            completed: { type: \"boolean\" }\n        },\n        required: [\"id\", \"title\", \"completed\"]\n    };\n\n    pm.response.to.have.jsonSchema(schema);\n});\n</code></pre> <p>Test: Check Array Length</p> <pre><code>pm.test(\"Returns at least 5 tasks\", function () {\n    const response = pm.response.json();\n    pm.expect(response.results).to.have.length.of.at.least(5);\n});\n</code></pre> <p>Test: Validate All Items in Array</p> <pre><code>pm.test(\"All tasks have required fields\", function () {\n    const response = pm.response.json();\n    response.results.forEach(function(task) {\n        pm.expect(task).to.have.property(\"id\");\n        pm.expect(task).to.have.property(\"title\");\n        pm.expect(task.id).to.be.a(\"number\");\n    });\n});\n</code></pre> <p>Test: Save Data for Next Request</p> <pre><code>pm.test(\"Save task ID for next request\", function () {\n    const response = pm.response.json();\n    pm.environment.set(\"task_id\", response.id);\n    pm.collectionVariables.set(\"last_created_task_id\", response.id);\n});\n</code></pre> <p>Test: Compare with Previous Response</p> <pre><code>pm.test(\"Task count increased\", function () {\n    const currentCount = pm.response.json().count;\n    const previousCount = pm.environment.get(\"previous_task_count\") || 0;\n    pm.expect(currentCount).to.be.above(previousCount);\n    pm.environment.set(\"previous_task_count\", currentCount);\n});\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#test-organization","title":"Test Organization","text":"<p>Multiple Tests in One Request:</p> <pre><code>// Test 1: Status\npm.test(\"Status is 200\", () =&gt; pm.response.to.have.status(200));\n\n// Test 2: Response time\npm.test(\"Fast response\", () =&gt; {\n    pm.expect(pm.response.responseTime).to.be.below(300);\n});\n\n// Test 3: Data validation\npm.test(\"Valid task data\", () =&gt; {\n    const task = pm.response.json();\n    pm.expect(task).to.have.property(\"id\");\n    pm.expect(task).to.have.property(\"title\");\n    pm.expect(task.completed).to.be.a(\"boolean\");\n});\n</code></pre> <p>Descriptive Test Names:</p> <pre><code>// \u274c Bad\npm.test(\"Test 1\", () =&gt; {});\n\n// \u2705 Good\npm.test(\"GET /api/tasks/ returns 200 status\", () =&gt; {\n    pm.response.to.have.status(200);\n});\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#collection-level-tests","title":"Collection-Level Tests","text":"<p>Why: Run tests after every request in collection.</p> <p>Setting up:</p> <ol> <li>Right-click collection \u2192 \"Edit\"</li> <li>Go to \"Tests\" tab</li> <li>Add tests that run after each request</li> </ol> <p>Example Collection Test:</p> <pre><code>// Log all requests\nconsole.log(\"Request:\", pm.request.url.toString());\n\n// Check if request was successful\npm.test(\"Request completed\", () =&gt; {\n    pm.expect(pm.response.code).to.be.oneOf([200, 201, 204]);\n});\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#pre-request-scripts","title":"Pre-request Scripts","text":""},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#what-are-pre-request-scripts","title":"What are Pre-request Scripts?","text":"<p>Scripts that run before the request is sent. Useful for:</p> <ul> <li>Setting dynamic headers</li> <li>Generating tokens</li> <li>Calculating values</li> <li>Preparing request data</li> </ul> <p>When they run: Just before sending the request</p> <p>Location: \"Pre-request Script\" tab</p>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#common-use-cases","title":"Common Use Cases","text":"<p>1. Set Timestamp Header</p> <pre><code>// Set current timestamp\npm.environment.set(\"timestamp\", Date.now());\n\n// Or ISO format\npm.environment.set(\"iso_timestamp\", new Date().toISOString());\n</code></pre> <p>2. Generate Random Data</p> <pre><code>// Generate random email\nconst randomEmail = `user${Math.floor(Math.random() * 10000)}@example.com`;\npm.environment.set(\"random_email\", randomEmail);\n\n// Generate random ID\nconst randomId = Math.floor(Math.random() * 1000);\npm.variables.set(\"random_id\", randomId);\n</code></pre> <p>3. Calculate Hash/Signature</p> <pre><code>// Example: Calculate HMAC signature\nconst crypto = require('crypto-js');\nconst message = pm.request.url.toString() + pm.request.body;\nconst secret = pm.environment.get(\"api_secret\");\nconst signature = crypto.HmacSHA256(message, secret).toString();\npm.environment.set(\"signature\", signature);\n</code></pre> <p>4. Refresh Token if Expired</p> <pre><code>// Check if token is expired\nconst tokenExpiresAt = pm.environment.get(\"token_expires_at\");\nconst now = Date.now();\n\nif (!tokenExpiresAt || now &gt;= tokenExpiresAt) {\n    // Refresh token\n    pm.sendRequest({\n        url: pm.environment.get(\"base_url\") + \"/api/token/refresh/\",\n        method: \"POST\",\n        header: { \"Content-Type\": \"application/json\" },\n        body: {\n            mode: \"raw\",\n            raw: JSON.stringify({\n                refresh: pm.environment.get(\"refresh_token\")\n            })\n        }\n    }, function (err, res) {\n        if (!err &amp;&amp; res.code === 200) {\n            const response = res.json();\n            pm.environment.set(\"access_token\", response.access);\n            pm.environment.set(\"token_expires_at\", Date.now() + 3600000);\n        }\n    });\n}\n</code></pre> <p>5. Set Dynamic Headers</p> <pre><code>// Set custom header with timestamp\npm.request.headers.add({\n    key: \"X-Request-ID\",\n    value: pm.variables.replaceIn(\"{{$randomUUID}}\")\n});\n\n// Set authorization header dynamically\nconst token = pm.environment.get(\"access_token\");\nif (token) {\n    pm.request.headers.add({\n        key: \"Authorization\",\n        value: \"Bearer \" + token\n    });\n}\n</code></pre> <p>6. Modify Request Body</p> <pre><code>// Get current body\nconst body = JSON.parse(pm.request.body.raw);\n\n// Modify it\nbody.created_at = new Date().toISOString();\nbody.user_id = pm.environment.get(\"user_id\");\n\n// Update request body\npm.request.body.raw = JSON.stringify(body);\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#collection-level-pre-request-scripts","title":"Collection-Level Pre-request Scripts","text":"<p>Why: Run script before every request in collection.</p> <p>Setting up:</p> <ol> <li>Right-click collection \u2192 \"Edit\"</li> <li>Go to \"Pre-request Script\" tab</li> <li>Add script</li> </ol> <p>Example: Set Common Headers</p> <pre><code>// Set common headers for all requests\npm.request.headers.add({\n    key: \"X-API-Version\",\n    value: \"v1\"\n});\n\npm.request.headers.add({\n    key: \"X-Client-ID\",\n    value: pm.environment.get(\"client_id\")\n});\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#running-collections-and-automation","title":"Running Collections and Automation","text":""},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#collection-runner","title":"Collection Runner","text":"<p>What it does: Runs multiple requests in sequence automatically.</p> <p>Use cases:</p> <ul> <li>Test entire API workflow</li> <li>Regression testing</li> <li>Performance testing</li> <li>Automated test suites</li> </ul> <p>How to use:</p> <ol> <li>Right-click collection \u2192 \"Run collection\"</li> <li>Configure settings:</li> <li>Iterations: How many times to run (e.g., 1, 5, 10)</li> <li>Delay: Milliseconds between requests</li> <li>Data File: CSV/JSON with test data</li> <li>Select Requests: Choose which requests to run</li> <li>Click \"Run \" <li>View results</li>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#collection-runner-settings","title":"Collection Runner Settings","text":"<p>Iterations:</p> <ul> <li>Run collection multiple times</li> <li>Useful for load testing</li> <li>Example: 10 iterations = run all requests 10 times</li> </ul> <p>Delay:</p> <ul> <li>Wait time between requests (milliseconds)</li> <li>Prevents overwhelming server</li> <li>Example: 1000ms = 1 second delay</li> </ul> <p>Data File:</p> <ul> <li>CSV or JSON file with test data</li> <li>Each iteration uses different row</li> <li>Example: Test with different users</li> </ul> <p>Request Order:</p> <ul> <li>Drag requests to reorder</li> <li>Run in specific sequence</li> <li>Example: Login \u2192 Create \u2192 Read \u2192 Update \u2192 Delete</li> </ul> <p>Stop on Error:</p> <ul> <li>Stop if any request fails</li> <li>Useful for debugging</li> <li>Or continue and report all errors</li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#viewing-results","title":"Viewing Results","text":"<p>Summary:</p> <ul> <li>Total requests run</li> <li>Passed/Failed count</li> <li>Average response time</li> </ul> <p>Request Details:</p> <ul> <li>Individual request results</li> <li>Test results for each</li> <li>Response data</li> </ul> <p>Export Results:</p> <ul> <li>Save as JSON/HTML</li> <li>Share with team</li> <li>Include in reports</li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#newman-command-line-runner","title":"Newman - Command Line Runner","text":"<p>What is Newman? Postman's command-line collection runner.</p> <p>Why use it?</p> <ul> <li>Run in CI/CD pipelines</li> <li>Automated testing</li> <li>No GUI required</li> <li>Integrate with scripts</li> </ul> <p>Installation:</p> <pre><code># Using npm\nnpm install -g newman\n\n# Using yarn\nyarn global add newman\n\n# Verify installation\nnewman --version\n</code></pre> <p>Basic Usage:</p> <pre><code># Export collection from Postman first\n# Then run:\nnewman run collection.json\n</code></pre> <p>With Environment:</p> <pre><code>newman run collection.json -e environment.json\n</code></pre> <p>Generate HTML Report:</p> <pre><code># Install reporter\nnpm install -g newman-reporter-html\n\n# Run with HTML report\nnewman run collection.json -r html --reporter-html-export report.html\n</code></pre> <p>Common Options:</p> <pre><code># Run with iterations\nnewman run collection.json -n 5\n\n# Run with delay\nnewman run collection.json -d 1000\n\n# Stop on first error\nnewman run collection.json --bail\n\n# Verbose output\nnewman run collection.json --verbose\n</code></pre> <p>CI/CD Integration Example (GitHub Actions):</p> <pre><code>name: API Tests\n\non: [push]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Setup Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '16'\n      - name: Install Newman\n        run: npm install -g newman\n      - name: Run API Tests\n        run: newman run collection.json -e environment.json\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#mock-servers","title":"Mock Servers","text":""},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#what-are-mock-servers","title":"What are Mock Servers?","text":"<p>Mock servers simulate your API without needing the actual backend running.</p> <p>Why use them?</p> <ul> <li>Frontend Development: Test frontend before backend is ready</li> <li>Team Collaboration: Backend and frontend teams work in parallel</li> <li>Testing: Test error scenarios easily</li> <li>Documentation: Show API behavior</li> </ul> <p>Real-world analogy: Mock server is like a practice dummy - you can practice without the real thing.</p>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#creating-a-mock-server","title":"Creating a Mock Server","text":"<p>Method 1: From Collection</p> <ol> <li>Right-click collection \u2192 \"Mock Collection\"</li> <li>Enter mock server name</li> <li>Select environment (optional)</li> <li>Click \"Create Mock Server\"</li> <li>Copy mock server URL</li> </ol> <p>Method 2: From Request</p> <ol> <li>Open request</li> <li>Click \"Examples\" tab</li> <li>Click \"Add Example\"</li> <li>Set example response</li> <li>Save example</li> <li>Create mock server from collection</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#setting-up-example-responses","title":"Setting Up Example Responses","text":"<p>Why: Mock server uses examples to return responses.</p> <p>Steps:</p> <ol> <li>Open request in collection</li> <li>Click \"Examples\" tab (next to Params, Headers, etc.)</li> <li>Click \"Add Example\"</li> <li>Name example (e.g., \"Success Response\")</li> <li>Set response:</li> <li>Status Code: 200</li> <li>Body: JSON response</li> <li>Click \"Save\"</li> </ol> <p>Example: Task List Response</p> <pre><code>Status: 200 OK\nBody (raw JSON):\n{\n  \"count\": 2,\n  \"next\": null,\n  \"previous\": null,\n  \"results\": [\n    {\n      \"id\": 1,\n      \"title\": \"Example Task 1\",\n      \"completed\": false\n    },\n    {\n      \"id\": 2,\n      \"title\": \"Example Task 2\",\n      \"completed\": true\n    }\n  ]\n}\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#using-mock-server","title":"Using Mock Server","text":"<p>Get Mock URL:</p> <p>After creating mock server, you'll get a URL like:</p> <pre><code>https://abc123.mock.pstmn.io\n</code></pre> <p>Use in Requests:</p> <p>Replace your base URL with mock URL:</p> <pre><code>https://abc123.mock.pstmn.io/api/tasks/\n</code></pre> <p>Benefits:</p> <ul> <li>Works even if backend is down</li> <li>Consistent responses for testing</li> <li>Fast responses</li> <li>No database needed</li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#advanced-mock-server-features","title":"Advanced Mock Server Features","text":"<p>Multiple Examples:</p> <p>Create different examples for different scenarios:</p> <ul> <li>\"Success Response\" - 200 OK</li> <li>\"Not Found\" - 404</li> <li>\"Unauthorized\" - 401</li> <li>\"Server Error\" - 500</li> </ul> <p>Conditional Responses:</p> <p>Use pre-request scripts to return different responses based on request data.</p> <p>Private Mock Servers:</p> <ul> <li>Only accessible with API key</li> <li>More secure</li> <li>For team use only</li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#api-documentation","title":"API Documentation","text":""},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#auto-generate-documentation","title":"Auto-Generate Documentation","text":"<p>Postman can automatically generate API documentation from your collections.</p> <p>Why:</p> <ul> <li>Always Up-to-date: Documentation matches your API</li> <li>Easy Sharing: Share with team or public</li> <li>Interactive: Try requests directly from docs</li> <li>Professional: Looks polished</li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#generating-documentation","title":"Generating Documentation","text":"<p>Steps:</p> <ol> <li>Open collection</li> <li>Click \"View Documentation\" (or right-click \u2192 \"View Documentation\")</li> <li>Click \"Publish\" (if not published)</li> <li>Configure:</li> <li>Visibility: Public, Team, or Private</li> <li>Description: Add overview</li> <li>Custom Domain: Use your domain (optional)</li> <li>Click \"Publish\"</li> <li>Copy documentation URL</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#documenting-requests","title":"Documenting Requests","text":"<p>Add Descriptions:</p> <ol> <li>Open request</li> <li>Click request name to edit</li> <li>Add description in markdown:</li> </ol> <pre><code>## Get Task List\n\nRetrieves a list of all tasks for the authenticated user.\n\n### Parameters\n\n- `page` (optional): Page number for pagination\n- `limit` (optional): Number of items per page\n\n### Response\n\nReturns a paginated list of tasks.\n</code></pre> <p>Add Examples:</p> <ol> <li>Go to \"Examples\" tab</li> <li>Add multiple examples:</li> <li>Success response</li> <li>Error responses</li> <li>Edge cases</li> </ol> <p>Add Request/Response Schemas:</p> <p>Document the expected request and response structure.</p>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#sharing-documentation","title":"Sharing Documentation","text":"<p>Public Documentation:</p> <ul> <li>Anyone with link can view</li> <li>Great for public APIs</li> <li>Searchable</li> </ul> <p>Team Documentation:</p> <ul> <li>Only team members can view</li> <li>Requires Postman account</li> <li>Can comment and collaborate</li> </ul> <p>Private Documentation:</p> <ul> <li>Only you can view</li> <li>For personal use</li> <li>Still accessible via link</li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#testing-flask-apis-step-by-step","title":"Testing Flask APIs - Step by Step","text":""},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#complete-workflow-example","title":"Complete Workflow Example","text":"<p>Let's test a complete Flask Task API workflow.</p> <p>Prerequisites:</p> <ul> <li>Flask server running on <code>http://127.0.0.1:5000</code></li> <li>Task API with authentication (for example, using <code>flask-jwt-extended</code>)</li> <li>User account created</li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#step-1-setup-environment","title":"Step 1: Setup Environment","text":"<p>Create Environment Variables:</p> <ol> <li>Create \"Development\" environment</li> <li>Add variables:</li> <li><code>base_url</code>: <code>http://127.0.0.1:5000</code></li> <li><code>username</code>: <code>admin@example.com</code></li> <li><code>password</code>: <code>password123</code></li> <li><code>access_token</code>: (leave empty)</li> <li><code>refresh_token</code>: (leave empty)</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#step-2-create-collection","title":"Step 2: Create Collection","text":"<p>Create \"Flask Task API\" Collection</p> <p>Organize requests in folders:</p> <ul> <li>Authentication</li> <li>Tasks (CRUD operations)</li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#step-3-login-request","title":"Step 3: Login Request","text":"<p>Request Configuration:</p> <pre><code>Method: POST\nURL: {{base_url}}/auth/login\nHeaders:\n  Content-Type: application/json\nBody (raw JSON):\n{\n  \"email\": \"{{username}}\",\n  \"password\": \"{{password}}\"\n}\n</code></pre> <p>Tests:</p> <pre><code>// Check status\npm.test(\"Status is 200\", () =&gt; {\n    pm.response.to.have.status(200);\n});\n\n// Save tokens (assumes access_token and optional refresh_token)\nconst response = pm.response.json();\npm.environment.set(\"access_token\", response.access_token);\nif (response.refresh_token) {\n    pm.environment.set(\"refresh_token\", response.refresh_token);\n}\n\n// Verify token exists\npm.test(\"Access token received\", () =&gt; {\n    pm.expect(response).to.have.property(\"access_token\");\n    pm.expect(response.access_token).to.be.a(\"string\");\n});\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#step-4-list-tasks","title":"Step 4: List Tasks","text":"<p>Request Configuration:</p> <pre><code>Method: GET\nURL: {{base_url}}/api/tasks/\nAuthorization:\n  Type: Bearer Token\n  Token: {{access_token}}\n</code></pre> <p>Tests:</p> <pre><code>pm.test(\"Status is 200\", () =&gt; {\n    pm.response.to.have.status(200);\n});\n\npm.test(\"Response is JSON\", () =&gt; {\n    pm.response.to.be.json;\n});\n\npm.test(\"Has results array\", () =&gt; {\n    const response = pm.response.json();\n    pm.expect(response).to.have.property(\"results\");\n    pm.expect(response.results).to.be.an(\"array\");\n});\n\npm.test(\"Fast response\", () =&gt; {\n    pm.expect(pm.response.responseTime).to.be.below(500);\n});\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#step-5-create-task","title":"Step 5: Create Task","text":"<p>Request Configuration:</p> <pre><code>Method: POST\nURL: {{base_url}}/api/tasks/\nAuthorization:\n  Type: Bearer Token\n  Token: {{access_token}}\nHeaders:\n  Content-Type: application/json\nBody (raw JSON):\n{\n  \"title\": \"Test Task from Postman\",\n  \"description\": \"Created via Postman\",\n  \"completed\": false\n}\n</code></pre> <p>Tests:</p> <pre><code>pm.test(\"Status is 201\", () =&gt; {\n    pm.response.to.have.status(201);\n});\n\npm.test(\"Task created with ID\", () =&gt; {\n    const response = pm.response.json();\n    pm.expect(response).to.have.property(\"id\");\n    pm.environment.set(\"created_task_id\", response.id);\n});\n\npm.test(\"Task has correct data\", () =&gt; {\n    const response = pm.response.json();\n    pm.expect(response.title).to.equal(\"Test Task from Postman\");\n    pm.expect(response.completed).to.be.false;\n});\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#step-6-get-single-task","title":"Step 6: Get Single Task","text":"<p>Request Configuration:</p> <pre><code>Method: GET\nURL: {{base_url}}/api/tasks/{{created_task_id}}/\nAuthorization:\n  Type: Bearer Token\n  Token: {{access_token}}\n</code></pre> <p>Tests:</p> <pre><code>pm.test(\"Status is 200\", () =&gt; {\n    pm.response.to.have.status(200);\n});\n\npm.test(\"Returns correct task\", () =&gt; {\n    const response = pm.response.json();\n    pm.expect(response.id).to.equal(parseInt(pm.environment.get(\"created_task_id\")));\n});\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#step-7-update-task","title":"Step 7: Update Task","text":"<p>Request Configuration:</p> <pre><code>Method: PATCH\nURL: {{base_url}}/api/tasks/{{created_task_id}}/\nAuthorization:\n  Type: Bearer Token\n  Token: {{access_token}}\nHeaders:\n  Content-Type: application/json\nBody (raw JSON):\n{\n  \"completed\": true\n}\n</code></pre> <p>Tests:</p> <pre><code>pm.test(\"Status is 200\", () =&gt; {\n    pm.response.to.have.status(200);\n});\n\npm.test(\"Task updated\", () =&gt; {\n    const response = pm.response.json();\n    pm.expect(response.completed).to.be.true;\n});\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#step-8-delete-task","title":"Step 8: Delete Task","text":"<p>Request Configuration:</p> <pre><code>Method: DELETE\nURL: {{base_url}}/api/tasks/{{created_task_id}}/\nAuthorization:\n  Type: Bearer Token\n  Token: {{access_token}}\n</code></pre> <p>Tests:</p> <pre><code>pm.test(\"Status is 204\", () =&gt; {\n    pm.response.to.have.status(204);\n});\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#step-9-test-error-cases","title":"Step 9: Test Error Cases","text":"<p>Test 401 Unauthorized:</p> <pre><code>Method: GET\nURL: {{base_url}}/api/tasks/\nAuthorization: (remove or use invalid token)\n</code></pre> <p>Tests:</p> <pre><code>pm.test(\"Status is 401\", () =&gt; {\n    pm.response.to.have.status(401);\n});\n</code></pre> <p>Test 404 Not Found:</p> <pre><code>Method: GET\nURL: {{base_url}}/api/tasks/99999/\nAuthorization:\n  Type: Bearer Token\n  Token: {{access_token}}\n</code></pre> <p>Tests:</p> <pre><code>pm.test(\"Status is 404\", () =&gt; {\n    pm.response.to.have.status(404);\n});\n</code></pre>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#step-10-run-collection","title":"Step 10: Run Collection","text":"<ol> <li>Right-click collection \u2192 \"Run collection\"</li> <li>Ensure requests are in correct order:</li> <li>Login</li> <li>List Tasks</li> <li>Create Task</li> <li>Get Task</li> <li>Update Task</li> <li>Delete Task</li> <li>Click \"Run\"</li> <li>Review results</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#common-errors-and-solutions","title":"Common Errors and Solutions","text":""},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#error-could-not-get-response","title":"Error: \"Could not get response\"","text":"<p>Causes:</p> <ul> <li>Server not running</li> <li>Wrong URL</li> <li>Network issues</li> <li>Firewall blocking</li> </ul> <p>Solutions:</p> <ol> <li>Check if your Flask server is running: <code>python app.py</code> or <code>flask run</code></li> <li>Verify URL is correct</li> <li>Check network connection</li> <li>Try <code>http://127.0.0.1:5000</code> in browser first</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#error-401-unauthorized","title":"Error: \"401 Unauthorized\"","text":"<p>Causes:</p> <ul> <li>Missing authentication</li> <li>Invalid token</li> <li>Expired token</li> </ul> <p>Solutions:</p> <ol> <li>Check Authorization tab is configured</li> <li>Verify token is valid (not expired)</li> <li>Re-login to get new token</li> <li>Check token format: <code>Bearer &lt;token&gt;</code></li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#error-404-not-found","title":"Error: \"404 Not Found\"","text":"<p>Causes:</p> <ul> <li>Wrong URL path</li> <li>API endpoint doesn't exist</li> <li>Typo in URL</li> </ul> <p>Solutions:</p> <ol> <li>Verify URL matches your Flask routes and blueprints</li> <li>Confirm the HTTP method (GET/POST/PUT/DELETE) is correct for that route</li> <li>Test URL in browser first</li> <li>Check for trailing slashes</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#error-400-bad-request","title":"Error: \"400 Bad Request\"","text":"<p>Causes:</p> <ul> <li>Invalid JSON in body</li> <li>Missing required fields</li> <li>Wrong data types</li> </ul> <p>Solutions:</p> <ol> <li>Validate JSON syntax (use JSON validator)</li> <li>Check required fields in API documentation</li> <li>Verify data types match API expectations</li> <li>Check Content-Type header is <code>application/json</code></li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#error-500-internal-server-error","title":"Error: \"500 Internal Server Error\"","text":"<p>Causes:</p> <ul> <li>Server-side error</li> <li>Database issue</li> <li>Code bug</li> </ul> <p>Solutions:</p> <ol> <li>Check Django server logs</li> <li>Verify database is accessible</li> <li>Check for Python errors in console</li> <li>Review API code for bugs</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#error-cors-error","title":"Error: \"CORS Error\"","text":"<p>Causes:</p> <ul> <li>CORS not configured in Django</li> <li>Wrong origin</li> </ul> <p>Solutions:</p> <ol> <li>Install django-cors-headers: <code>pip install django-cors-headers</code></li> <li>Add to INSTALLED_APPS: <code>'corsheaders'</code></li> <li>Add middleware</li> <li>Configure CORS_ALLOWED_ORIGINS</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#error-ssl-certificate-error","title":"Error: \"SSL Certificate Error\"","text":"<p>Causes:</p> <ul> <li>Self-signed certificate</li> <li>Invalid certificate</li> </ul> <p>Solutions:</p> <ol> <li>For development: Disable SSL verification (Settings \u2192 General)</li> <li>For production: Use valid SSL certificate</li> <li>Add certificate to Postman (Settings \u2192 Certificates)</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#best-practices","title":"Best Practices","text":""},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#1-organize-your-collections","title":"1. Organize Your Collections","text":"<p>Do:</p> <ul> <li>Group related requests</li> <li>Use folders for categories</li> <li>Name requests descriptively</li> <li>Add descriptions</li> </ul> <p>Don't:</p> <ul> <li>Put everything in one collection</li> <li>Use vague names like \"Test 1\"</li> <li>Mix different APIs</li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#2-use-environments","title":"2. Use Environments","text":"<p>Do:</p> <ul> <li>Create separate environments for dev/staging/prod</li> <li>Use variables for URLs and credentials</li> <li>Keep sensitive data in environment variables</li> </ul> <p>Don't:</p> <ul> <li>Hardcode URLs in requests</li> <li>Commit environment files with real credentials</li> <li>Mix environment values</li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#3-write-meaningful-tests","title":"3. Write Meaningful Tests","text":"<p>Do:</p> <ul> <li>Test status codes</li> <li>Validate response structure</li> <li>Check response times</li> <li>Use descriptive test names</li> </ul> <p>Don't:</p> <ul> <li>Skip tests</li> <li>Write vague test names</li> <li>Test only happy paths</li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#4-document-your-requests","title":"4. Document Your Requests","text":"<p>Do:</p> <ul> <li>Add descriptions to requests</li> <li>Document parameters</li> <li>Include examples</li> <li>Explain expected responses</li> </ul> <p>Don't:</p> <ul> <li>Leave requests undocumented</li> <li>Assume others know what requests do</li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#5-version-control","title":"5. Version Control","text":"<p>Do:</p> <ul> <li>Export collections regularly</li> <li>Commit collection files to Git</li> <li>Tag versions</li> <li>Document changes</li> </ul> <p>Don't:</p> <ul> <li>Only keep collections in Postman</li> <li>Forget to export</li> <li>Lose work</li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#6-security","title":"6. Security","text":"<p>Do:</p> <ul> <li>Use environment variables for secrets</li> <li>Don't commit tokens</li> <li>Rotate API keys regularly</li> <li>Use different credentials per environment</li> </ul> <p>Don't:</p> <ul> <li>Hardcode passwords</li> <li>Share environment files publicly</li> <li>Use production credentials in dev</li> </ul>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#exercises","title":"Exercises","text":""},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#exercise-1-complete-crud-workflow","title":"Exercise 1: Complete CRUD Workflow","text":"<p>Task:</p> <ol> <li>Create a collection for a Book API</li> <li>Set up environment with base URL</li> <li>Create requests for:</li> <li>Login (get token)</li> <li>List books</li> <li>Create book</li> <li>Get single book</li> <li>Update book</li> <li>Delete book</li> <li>Add tests to each request</li> <li>Run collection and verify all pass</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#exercise-2-error-handling","title":"Exercise 2: Error Handling","text":"<p>Task:</p> <ol> <li>Create requests to test error cases:</li> <li>401 Unauthorized (no token)</li> <li>404 Not Found (invalid ID)</li> <li>400 Bad Request (invalid data)</li> <li>403 Forbidden (no permission)</li> <li>Write tests to verify correct error codes</li> <li>Test error response structure</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#exercise-3-pagination-testing","title":"Exercise 3: Pagination Testing","text":"<p>Task:</p> <ol> <li>Create requests to test pagination:</li> <li>Get first page</li> <li>Get second page</li> <li>Test page size parameter</li> <li>Write tests to verify:</li> <li>Correct number of items per page</li> <li>Next/previous page links</li> <li>Total count</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#exercise-4-filtering-and-searching","title":"Exercise 4: Filtering and Searching","text":"<p>Task:</p> <ol> <li>Test filtering endpoints:</li> <li>Filter by status</li> <li>Filter by date range</li> <li>Search by keyword</li> <li>Write tests to verify:</li> <li>Filters work correctly</li> <li>Results match filters</li> <li>Empty results handled</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#exercise-5-token-refresh-flow","title":"Exercise 5: Token Refresh Flow","text":"<p>Task:</p> <ol> <li>Create pre-request script to:</li> <li>Check if token is expired</li> <li>Refresh token if needed</li> <li>Use new token automatically</li> <li>Test with expired token</li> <li>Verify token refresh works</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#exercise-6-mock-server","title":"Exercise 6: Mock Server","text":"<p>Task:</p> <ol> <li>Create mock server for your API</li> <li>Add example responses for:</li> <li>Success cases</li> <li>Error cases</li> <li>Test frontend with mock server</li> <li>Verify mock responses match real API</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#exercise-7-collection-runner","title":"Exercise 7: Collection Runner","text":"<p>Task:</p> <ol> <li>Set up collection runner</li> <li>Configure:</li> <li>Multiple iterations</li> <li>Delay between requests</li> <li>Data file with test data</li> <li>Run collection</li> <li>Analyze results</li> <li>Export report</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#exercise-8-documentation","title":"Exercise 8: Documentation","text":"<p>Task:</p> <ol> <li>Add descriptions to all requests</li> <li>Document parameters and responses</li> <li>Add multiple examples</li> <li>Publish documentation</li> <li>Share with team</li> </ol>"},{"location":"POSTMAN_GUIDE_PART2_ADVANCED.html#next-steps","title":"Next Steps","text":"<p>Congratulations! You've completed both parts of the Postman guide. You now know:</p> <p>Part 1:</p> <ul> <li>\u2705 Installation and setup</li> <li>\u2705 Interface navigation</li> <li>\u2705 Basic requests</li> <li>\u2705 Collections and environments</li> </ul> <p>Part 2:</p> <ul> <li>\u2705 Authentication (JWT, Basic, API Key)</li> <li>\u2705 Writing tests and scripts</li> <li>\u2705 Automation and collection runner</li> <li>\u2705 Mock servers and documentation</li> <li>\u2705 Complete Flask API testing workflow</li> </ul> <p>Continue Learning:</p> <ol> <li>Practice: Test your own APIs</li> <li>Explore: Try advanced Postman features</li> <li>Automate: Set up CI/CD with Newman</li> <li>Collaborate: Share collections with team</li> <li>Document: Create comprehensive API docs</li> </ol> <p>Resources:</p> <ul> <li>Postman Learning Center</li> <li>Postman API Documentation</li> <li>Newman Documentation</li> <li>Postman Community</li> </ul> <p>Related Guides:</p> <ul> <li>cURL Guide - Command-line API testing</li> </ul> <p>Happy API Testing! \ud83d\ude80</p>"}]}